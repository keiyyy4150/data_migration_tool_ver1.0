Attribute VB_Name = "modJoinAndEval"
Option Explicit

' ===========================
' JOIN / EXPR / 評価系の中核
' ※初心者向けにコメント多め
' ===========================

' ▼ ここで参照するグローバル（他モジュールで定義済み）
'   - TableData : 読み込んだ各CSVの2次元配列（Key=テーブル名）
'   - KeyIndex  : 各テーブルのキー辞書（Key=連結キー文字列, Val=行Index）
'   - Map_*     : Mapping のキャッシュ（列名/型/ロジック/モード/定義/表名/元列 など）
'   - m_baseTblName, m_baseRowIdx() : ベース表名と、出力行→ベース行Indexの対応
'   - CurrentEncodingMode : 読み書きエンコード

'-------------------------------------------
' 1) 無加工JOIN結果を構築
'    ・ベース表の各行を1行ずつ処理
'    ・各出力列のモード（VALUE/CONCAT/EXPR）に応じて値を作る（raw版）
'-------------------------------------------
Public Function BuildJoinedRaw(baseTbl As String) As Variant
    Dim outColsCnt As Long: outColsCnt = UBound(Map_OutCols)
    Dim outRows As Long, result() As Variant
    Dim baseArr As Variant, haveBase As Boolean
    Dim r As Long, c As Long

    haveBase = (Len(baseTbl) > 0)
    If haveBase Then
        baseArr = TableData(baseTbl)
        outRows = Application.Max(0, UBound(baseArr, 1) - 1) ' ヘッダ除く
        ReDim m_baseRowIdx(1 To outRows)
    Else
        outRows = 0
    End If

    If outRows = 0 Then
        Dim emptyArr(1 To 1, 1 To outColsCnt) As Variant
        BuildJoinedRaw = emptyArr
        Exit Function
    End If

    ReDim result(1 To outRows, 1 To outColsCnt)

    Dim baseKeyCols() As Long
    If haveBase Then baseKeyCols = CollectKeyColIndexesForBase(baseArr, baseTbl)

    For r = 2 To UBound(baseArr, 1) ' ベースのデータ行
        Dim myKey As String
        If haveBase Then myKey = BuildKeyFromRow(baseArr, r, baseKeyCols)
        m_baseRowIdx(r - 1) = r

        For c = 1 To outColsCnt
            Select Case Map_Mode(c)
                Case "CONCAT"
                    result(r - 1, c) = BuildConcatRawValue(Map_Def(c), baseTbl, r, myKey)
                Case "EXPR"
                    ' ★IF/IFALL/IFANY 対応：raw段階でも評価
                    result(r - 1, c) = EvaluateExpr(Map_Def(c), baseTbl, r, myKey, False, c)
                Case Else ' VALUE
                    result(r - 1, c) = BuildValueModeRaw(c, baseTbl, r, myKey)
            End Select
        Next c
    Next r

    BuildJoinedRaw = result
End Function

'-------------------------------------------
' 2) VALUE（優先/補完）の raw 取得
'    ・H列以降の各テーブルに対して、最初に見つかった値を取る
'    ・ベース表を優先、それ以外はJOIN（KeyIndex）で引いて取得
'-------------------------------------------
Public Function BuildValueModeRaw(colIndex As Long, baseTbl As String, baseRow As Long, myKey As String) As Variant
    Dim t As Long, srcColName As String, srcColIndex As Long, v As Variant
    v = ""
    If (Not Not Map_TblNames) = 0 Then Exit Function

    For t = LBound(Map_TblNames) To UBound(Map_TblNames)
        If UBound(Map_SrcCols, 2) >= t Then
            srcColName = Map_SrcCols(colIndex, t)
            If Len(srcColName) > 0 Then
                If Map_TblNames(t) = baseTbl Then
                    srcColIndex = FindColumnIndex(TableData(baseTbl), srcColName)
                    If srcColIndex > 0 Then v = TableData(baseTbl)(baseRow, srcColIndex)
                    Exit For
                Else
                    Dim kd As Object, matchRow As Long, otherArr As Variant
                    Set kd = KeyIndex(Map_TblNames(t))
                    If Not kd Is Nothing Then
                        If kd.Exists(myKey) Then
                            matchRow = kd(myKey)
                            otherArr = TableData(Map_TblNames(t))
                            srcColIndex = FindColumnIndex(otherArr, srcColName)
                            If srcColIndex > 0 Then v = otherArr(matchRow, srcColIndex)
                            Exit For
                        End If
                    End If
                End If
            End If
        End If
    Next t
    BuildValueModeRaw = v
End Function

'-------------------------------------------
' 3) CONCAT（raw）：定義の列挙を無加工で改行結合
'    ・定義セルの区切りは「|」または「セル内改行」
'-------------------------------------------
Public Function BuildConcatRawValue(def As String, baseTbl As String, baseRow As Long, myKey As String) As String
    Dim parts As Collection: Set parts = SplitDefToParts(def)
    Dim i As Long, v As String, acc As String
    For i = 1 To parts.Count
        v = ResolveTokenRaw(parts(i), baseTbl, baseRow, myKey)
        If acc = "" Then acc = v Else If Len(v) > 0 Then acc = acc & vbLf & v
    Next
    BuildConcatRawValue = acc
End Function

'-------------------------------------------
' 4) EXPR を評価（raw / processed 共通の入口）
'    ・テンプレ（"..."）/ 四則演算 / IF*, IFALL, IFANY を判定して評価
'    ・processed=True の場合はトークン値に「型/ロジック」も適用
'    ・定義セルが複数行（Alt+Enter）の場合は、各行の結果を改行で連結
'-------------------------------------------
Public Function EvaluateExpr(def As String, baseTbl As String, baseRow As Long, myKey As String, _
                             ByVal processed As Boolean, Optional outColIndex As Long = -1) As Variant
    Dim lines As Collection: Set lines = SplitExprToLines(def)
    Dim i As Long, one As String, res As String, acc As String

    For i = 1 To lines.Count
        one = Trim$(lines(i))
        If one = "" Then GoTo CONTINUE_LINE

        If HasIFSyntax(one) Then
            ' IF/IFALL/IFANY の1行を評価（空なら無視）
            res = EvalIFLine(one, baseTbl, baseRow, myKey, processed, outColIndex)
            If Len(res) > 0 Then
                If acc = "" Then acc = res Else acc = acc & vbLf & res
            End If
        ElseIf InStr(one, """") > 0 Then
            ' テンプレ（"..."）
            res = ApplyTemplate(one, baseTbl, baseRow, myKey, processed, outColIndex)
            If acc = "" Then acc = res Else acc = acc & vbLf & res
        Else
            ' 数式（トークン→数値置換後に四則演算）
            Dim expr As String
            If processed Then
                expr = ReplaceTokensProcessedAsNumber(one, baseTbl, baseRow, myKey, outColIndex)
            Else
                expr = ReplaceTokensWithRaw(one, baseTbl, baseRow, myKey)
            End If
            res = CStr(SafeEval(expr))
            If acc = "" Then acc = res Else acc = acc & vbLf & res
        End If

CONTINUE_LINE:
    Next i

    ' processed=True かつ 出力列の型指定があるなら最終整形
    If processed And outColIndex > 0 Then
        EvaluateExpr = FinalizeByType(acc, Map_DataType(outColIndex))
    Else
        EvaluateExpr = acc
    End If
End Function

'-------------------------------------------
' 5) Process（加工段階）での全体変換
'    ・VALUE→型/置換
'    ・CONCAT→各トークンを加工して改行結合
'    ・EXPR→EvaluateExpr(processed:=True) で再評価
'-------------------------------------------
Public Function ApplyTransformSmart(src As Variant) As Variant
    Dim rows As Long, cols As Long
    rows = UBound(src, 1): cols = UBound(src, 2)
    Dim dst() As Variant: ReDim dst(1 To rows, 1 To cols)

    Dim r As Long, c As Long
    For r = 1 To rows
        For c = 1 To cols
            Select Case Map_Mode(c)
                Case "CONCAT"
                    dst(r, c) = BuildConcatProcessedValue(Map_Def(c), m_baseTblName, m_baseRowIdx(r), GetKeyForRow(r), c)
                Case "EXPR"
                    dst(r, c) = EvaluateExpr(Map_Def(c), m_baseTblName, m_baseRowIdx(r), GetKeyForRow(r), True, c)
                Case Else
                    dst(r, c) = ApplyOneValueTransform(src(r, c), Map_DataType(c), Map_Logic(c))
            End Select
        Next c
    Next r
    ApplyTransformSmart = dst
End Function

'-------------------------------------------
' 6) CONCAT（processed）：各トークンを加工（型/置換）してから改行結合
'-------------------------------------------
Public Function BuildConcatProcessedValue(def As String, baseTbl As String, baseRow As Long, myKey As String, outColIndex As Long) As String
    Dim parts As Collection: Set parts = SplitDefToParts(def)
    Dim i As Long, v As String, acc As String
    For i = 1 To parts.Count
        v = ResolveTokenProcessed(parts(i), baseTbl, baseRow, myKey, outColIndex)
        If acc = "" Then acc = v Else If Len(v) > 0 Then acc = acc & vbLf & v
    Next
    BuildConcatProcessedValue = acc
End Function

'-------------------------------------------
' 7) トークン置換（raw/processed 共通ユーティリティ）
'-------------------------------------------
Public Function ReplaceTokensWithRaw(def As String, baseTbl As String, baseRow As Long, myKey As String) As String
    Dim s As String: s = def
    Dim pos As Long, pos2 As Long, token As String, valStr As String
    pos = InStr(s, "{")
    Do While pos > 0
        pos2 = InStr(pos + 1, s, "}")
        If pos2 = 0 Then Exit Do
        token = Mid$(s, pos + 1, pos2 - pos - 1) ' "A.col"
        valStr = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
        If Not IsNumeric(valStr) Then valStr = "0"
        s = Left$(s, pos - 1) & valStr & Mid$(s, pos2 + 1)
        pos = InStr(pos + Len(valStr), s, "{")
    Loop
    ReplaceTokensWithRaw = s
End Function

Public Function ReplaceTokensProcessedAsNumber(def As String, baseTbl As String, baseRow As Long, myKey As String, outColIndex As Long) As String
    Dim s As String: s = def
    Dim pos As Long, pos2 As Long, token As String, valStr As String
    pos = InStr(s, "{")
    Do While pos > 0
        pos2 = InStr(pos + 1, s, "}")
        If pos2 = 0 Then Exit Do
        token = Mid$(s, pos + 1, pos2 - pos - 1)
        valStr = ResolveTokenProcessed(token, baseTbl, baseRow, myKey, outColIndex)
        If Not IsNumeric(valStr) Then valStr = "0"
        s = Left$(s, pos - 1) & valStr & Mid$(s, pos2 + 1)
        pos = InStr(pos + Len(valStr), s, "{")
    Loop
    ReplaceTokensProcessedAsNumber = s
End Function

'-------------------------------------------
' 8) テンプレ文字列（"..."）を評価
'    ・{T.col} を raw / processed で展開して返す
'-------------------------------------------
Public Function ApplyTemplate(def As String, baseTbl As String, baseRow As Long, myKey As String, _
                              ByVal processed As Boolean, Optional outColIndex As Long = -1) As String
    Dim s As String: s = def
    Dim pos As Long, pos2 As Long, token As String, valStr As String
    pos = InStr(s, "{")
    Do While pos > 0
        pos2 = InStr(pos + 1, s, "}")
        If pos2 = 0 Then Exit Do
        token = Mid$(s, pos + 1, pos2 - pos - 1)
        If processed Then
            valStr = ResolveTokenProcessed(token, baseTbl, baseRow, myKey, outColIndex)
        Else
            valStr = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
        End If
        s = Left$(s, pos - 1) & valStr & Mid$(s, pos2 + 1)
        pos = InStr(pos + Len(valStr), s, "{")
    Loop
    ' 外側のダブルクォートを外す
    ApplyTemplate = Replace(s, """", "")
End Function

'-------------------------------------------
' 9) トークンの値を取得（raw / processed）
'-------------------------------------------
Public Function ResolveTokenRaw(token As String, baseTbl As String, baseRow As Long, myKey As String) As String
    Dim t As String, c As String, p As Long
    token = Replace(Replace(token, "{", ""), "}", "")
    p = InStr(token, ".")
    If p = 0 Then ResolveTokenRaw = "": Exit Function
    t = Left$(token, p - 1): c = Mid$(token, p + 1)
    ResolveTokenRaw = GetValueFromTable(t, c, baseTbl, baseRow, myKey)
End Function

Public Function ResolveTokenProcessed(token As String, baseTbl As String, baseRow As Long, myKey As String, _
                                      Optional outColIndex As Long = -1) As String
    Dim raw As Variant
    raw = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
    If outColIndex <= 0 Then
        ResolveTokenProcessed = CStr(raw)
    Else
        ResolveTokenProcessed = ApplyOneValueTransform(raw, Map_DataType(outColIndex), Map_Logic(outColIndex))
    End If
End Function

'-------------------------------------------
' 10) 出力型の最終整形
'-------------------------------------------
Public Function FinalizeByType(v As Variant, dataType As String) As String
    Dim w As Variant: w = v
    Select Case UCase$(dataType)
        Case "NUMBER": If IsNumeric(w) And Len(w) > 0 Then w = CLng(w) Else w = ""
        Case "DATE":   If IsDate(w) And Len(w) > 0 Then w = Format$(CDate(w), "yyyy/mm/dd") Else w = ""
        Case Else:     w = CStr(w)
    End Select
    FinalizeByType = CStr(w)
End Function

'-------------------------------------------
' 11) IF/IFALL/IFANY の検出
'-------------------------------------------
Private Function HasIFSyntax(ByVal s As String) As Boolean
    s = UCase$(s)
    HasIFSyntax = (Left$(s, 3) = "IF(") Or (Left$(s, 6) = "IFALL(") Or (Left$(s, 6) = "IFANY(")
End Function

'-------------------------------------------
' 12) IF系1行の評価
'     ・"IF(...)" / "IFALL(...)" / "IFANY(...)" を解析し、文字列を返す
'     ・空文字（Else結果や条件不成立）は上位でスキップされる
'-------------------------------------------
Private Function EvalIFLine(ByVal line As String, baseTbl As String, baseRow As Long, myKey As String, _
                            ByVal processed As Boolean, ByVal outColIndex As Long) As String
    Dim fn As String, inside As String
    Dim pOpen As Long, pClose As Long

    ' 関数名と()内を取り出す
    pOpen = InStr(line, "("): pClose = InStrRev(line, ")")
    If pOpen = 0 Or pClose = 0 Or pClose <= pOpen Then Exit Function
    fn = UCase$(Left$(line, pOpen - 1))
    inside = Mid$(line, pOpen + 1, pClose - pOpen - 1)

    ' カンマで引数分割（クォートは保護）
    Dim args As Collection: Set args = SplitArgs(inside)
    If args.Count < 3 Then Exit Function ' 条件1個 + then + else は最低必要

    Dim thenText As String, elseText As String
    thenText = StripQuotes(args(args.Count - 1))
    elseText = StripQuotes(args(args.Count))

    Dim ok As Boolean
    Select Case fn
        Case "IF"
            ok = EvalOneCondition(args(1), baseTbl, baseRow, myKey, processed, outColIndex)
        Case "IFALL"
            ok = EvalAllConditions(args, 1, args.Count - 2, baseTbl, baseRow, myKey, processed, outColIndex)
        Case "IFANY"
            ok = EvalAnyConditions(args, 1, args.Count - 2, baseTbl, baseRow, myKey, processed, outColIndex)
        Case Else
            ok = False
    End Select

    If ok Then
        EvalIFLine = thenText
    Else
        EvalIFLine = elseText
    End If
End Function

'-------------------------------------------
' 13) 条件群（ALL / ANY）
'-------------------------------------------
Private Function EvalAllConditions(args As Collection, idxFrom As Long, idxTo As Long, _
                                   baseTbl As String, baseRow As Long, myKey As String, _
                                   ByVal processed As Boolean, ByVal outColIndex As Long) As Boolean
    Dim i As Long
    For i = idxFrom To idxTo
        If Not EvalOneCondition(args(i), baseTbl, baseRow, myKey, processed, outColIndex) Then
            EvalAllConditions = False: Exit Function
        End If
    Next
    EvalAllConditions = True
End Function

Private Function EvalAnyConditions(args As Collection, idxFrom As Long, idxTo As Long, _
                                   baseTbl As String, baseRow As Long, myKey As String, _
                                   ByVal processed As Boolean, ByVal outColIndex As Long) As Boolean
    Dim i As Long
    For i = idxFrom To idxTo
        If EvalOneCondition(args(i), baseTbl, baseRow, myKey, processed, outColIndex) Then
            EvalAnyConditions = True: Exit Function
        End If
    Next
    EvalAnyConditions = False
End Function

'-------------------------------------------
' 14) 単一条件の評価
'     ・記述形式： {T.col}='文字列'  だけをサポート（完全一致）
'-------------------------------------------
Private Function EvalOneCondition(cond As String, baseTbl As String, baseRow As Long, myKey As String, _
                                  ByVal processed As Boolean, ByVal outColIndex As Long) As Boolean
    Dim p As Long, leftExpr As String, rightExpr As String
    p = InStr(cond, "=")
    If p = 0 Then Exit Function

    leftExpr = Trim$(Left$(cond, p - 1))
    rightExpr = Trim$(Mid$(cond, p + 1))

    Dim expected As String: expected = StripQuotes(rightExpr)
    Dim actual As String
    If processed Then
        actual = ResolveTokenProcessed(Trim$(leftExpr), baseTbl, baseRow, myKey, outColIndex)
    Else
        actual = ResolveTokenRaw(Trim$(leftExpr), baseTbl, baseRow, myKey)
    End If

    EvalOneCondition = (actual = expected)
End Function

'-------------------------------------------
' 15) 文字列ユーティリティ
'-------------------------------------------
Private Function StripQuotes(ByVal s As String) As String
    s = Trim$(s)
    If (Left$(s, 1) = "'" And Right$(s, 1) = "'") Or (Left$(s, 1) = """" And Right$(s, 1) = """") Then
        StripQuotes = Mid$(s, 2, Len(s) - 2)
    Else
        StripQuotes = s
    End If
End Function

Private Function SplitArgs(ByVal s As String) As Collection
    ' 括弧1レベル内のカンマを分割。クォート中のカンマは保護。
    Dim col As New Collection
    Dim i As Long, ch As String * 1, inQ As Boolean, qChar As String * 1, buf As String
    For i = 1 To Len(s)
        ch = Mid$(s, i, 1)
        If ch = """" Or ch = "'" Then
            If inQ Then
                If ch = qChar Then inQ = False
            Else
                inQ = True: qChar = ch
            End If
            buf = buf & ch
        ElseIf ch = "," And Not inQ Then
            col.Add Trim$(buf): buf = ""
        Else
            buf = buf & ch
        End If
    Next
    If Len(buf) > 0 Or s = "" Then col.Add Trim$(buf)
    Set SplitArgs = col
End Function

Private Function SplitDefToParts(ByVal def As String) As Collection
    ' CONCAT/EXPR の定義を「|」またはセル内改行で分割
    Dim col As New Collection
    Dim tmp As String
    tmp = Replace(def, vbCr, "")
    tmp = Replace(tmp, "|", vbLf)
    Dim arr() As String, i As Long
    arr = Split(tmp, vbLf)
    For i = LBound(arr) To UBound(arr)
        If Trim$(arr(i)) <> "" Then col.Add Trim$(arr(i))
    Next
    Set SplitDefToParts = col
End Function

Private Function SplitExprToLines(ByVal def As String) As Collection
    ' EXPR用：1セルに複数行（Alt+Enter）なら、各行を独立評価して改行で連結
    Set SplitExprToLines = SplitDefToParts(def)
End Function

'-------------------------------------------
' 16) キー関連（既存のまま流用）
'-------------------------------------------
Public Function GetKeyForRow(r As Long) As String
    Dim baseArr As Variant, baseKeyCols() As Long
    If Len(m_baseTblName) = 0 Then GetKeyForRow = "": Exit Function
    baseArr = TableData(m_baseTblName)
    baseKeyCols = CollectKeyColIndexesForBase(baseArr, m_baseTblName)
    GetKeyForRow = BuildKeyFromRow(baseArr, m_baseRowIdx(r), baseKeyCols)
End Function

Public Function CollectKeyColIndexesForBase(baseArr As Variant, baseTbl As String) As Variant
    Dim tIdx As Long, i As Long, kc As Long
    tIdx = IndexOfTable(Map_TblNames, baseTbl)
    kc = 0
    For i = LBound(Map_OutCols) To UBound(Map_OutCols)
        If Map_IsKey(i) Then
            If (Not Not Map_TblNames) <> 0 And tIdx >= 0 Then
                If UBound(Map_SrcCols, 2) >= tIdx Then
                    If Len(Map_SrcCols(i, tIdx)) > 0 Then kc = kc + 1
                End If
            End If
        End If
    Next
    If kc = 0 Then CollectKeyColIndexesForBase = Array(): Exit Function

    Dim idx() As Long, cur As Long
    ReDim idx(1 To kc): cur = 0
    For i = LBound(Map_OutCols) To UBound(Map_OutCols)
        If Map_IsKey(i) Then
            If UBound(Map_SrcCols, 2) >= tIdx Then
                If Len(Map_SrcCols(i, tIdx)) > 0 Then
                    cur = cur + 1
                    idx(cur) = FindColumnIndex(baseArr, Map_SrcCols(i, tIdx))
                End If
            End If
        End If
    Next
    CollectKeyColIndexesForBase = idx
End Function

Public Function BuildKeyFromRow(arr As Variant, rowIdx As Long, keyColIdx() As Long) As String
    Dim i As Long, s As String: s = ""
    If Not Not keyColIdx Then
        For i = LBound(keyColIdx) To UBound(keyColIdx)
            If keyColIdx(i) > 0 Then s = s & "|" & CStr(arr(rowIdx, keyColIdx(i)))
        Next
    End If
    If Len(s) > 0 Then s = Mid$(s, 2)
    BuildKeyFromRow = s
End Function

Public Function FindColumnIndex(arr As Variant, colName As String) As Long
    Dim c As Long
    For c = 1 To UBound(arr, 2)
        If CStr(arr(1, c)) = colName Then FindColumnIndex = c: Exit Function
    Next
    FindColumnIndex = 0
End Function

Public Function IndexOfTable(tblNames() As String, name As String) As Long
    Dim i As Long
    For i = LBound(tblNames) To UBound(tblNames)
        If tblNames(i) = name Then IndexOfTable = i: Exit Function
    Next
    IndexOfTable = -1
End Function

'-------------------------------------------
' 17) 任意テーブル・カラムの値をキーで解決（既存）
'-------------------------------------------
Public Function GetValueFromTable(tbl As String, col As String, baseTbl As String, baseRow As Long, myKey As String) As String
    On Error GoTo SAFE
    Dim arr As Variant, cIdx As Long, kd As Object, rIdx As Long
    If tbl = baseTbl Then
        arr = TableData(tbl)
        cIdx = FindColumnIndex(arr, col)
        If cIdx > 0 Then GetValueFromTable = CStr(arr(baseRow, cIdx)) Else GetValueFromTable = ""
    Else
        Set kd = KeyIndex(tbl)
        If kd Is Nothing Then GetValueFromTable = "": Exit Function
        If Not kd.Exists(myKey) Then GetValueFromTable = "": Exit Function
        rIdx = kd(myKey)
        arr = TableData(tbl)
        cIdx = FindColumnIndex(arr, col)
        If cIdx > 0 Then GetValueFromTable = CStr(arr(rIdx, cIdx)) Else GetValueFromTable = ""
    End If
    Exit Function
SAFE:
    GetValueFromTable = ""
End Function

'-------------------------------------------
' 18) 値1つの型/置換（既存）
'-------------------------------------------
Public Function ApplyOneValueTransform(v As Variant, dataType As String, logic As String) As String
    Dim w As Variant: w = v
    Select Case UCase$(dataType)
        Case "NUMBER": If IsNumeric(w) And Len(w) > 0 Then w = CLng(w) Else w = ""
        Case "DATE":   If IsDate(w) And Len(w) > 0 Then w = Format$(CDate(w), "yyyy/mm/dd") Else w = ""
        Case Else:     w = CStr(w)
    End Select
    If Len(logic) > 0 Then
        Dim rules() As String, i As Long, pair() As String
        rules = Split(logic, ";")
        For i = LBound(rules) To UBound(rules)
            pair = Split(rules(i), "→")
            If UBound(pair) = 1 Then w = Replace(CStr(w), pair(0), pair(1))
        Next
    End If
    ApplyOneValueTransform = CStr(w)
End Function

'-------------------------------------------
' 19) 四則演算（既存）
'-------------------------------------------
Public Function SafeEval(ByVal expr As String) As Double
    expr = Replace(expr, " ", "")
    Dim nums() As Double, ops() As String, nTop As Long, oTop As Long
    ReDim nums(1 To 1): ReDim ops(1 To 1): nTop = 0: oTop = 0

    Dim i As Long, ch As String, num As String
    i = 1
    Do While i <= Len(expr)
        ch = Mid$(expr, i, 1)
        If ch Like "[0-9.]" Then
            num = ""
            Do While i <= Len(expr) And Mid$(expr, i, 1) Like "[0-9.]"
                num = num & Mid$(expr, i, 1): i = i + 1
            Loop
            nTop = nTop + 1: ReDim Preserve nums(1 To nTop)
            On Error Resume Next: nums(nTop) = CDbl(num): On Error GoTo 0
            GoTo CONT
        ElseIf ch = "(" Then
            oTop = oTop + 1: ReDim Preserve ops(1 To oTop): ops(oTop) = ch
        ElseIf ch = ")" Then
            Do While oTop > 0 And ops(oTop) <> "("
                ApplyOp nums, nTop, ops, oTop
            Loop
            If oTop > 0 And ops(oTop) = "(" Then oTop = oTop - 1
        ElseIf ch = "+" Or ch = "-" Or ch = "*" Or ch = "/" Then
            Do While oTop > 0 And Precedence(ops(oTop)) >= Precedence(ch)
                ApplyOp nums, nTop, ops, oTop
            Loop
            oTop = oTop + 1: ReDim Preserve ops(1 To oTop): ops(oTop) = ch
        End If
CONT:
        i = i + 1
    Loop
    Do While oTop > 0
        ApplyOp nums, nTop, ops, oTop
    Loop
    If nTop > 0 Then SafeEval = nums(nTop) Else SafeEval = 0
End Function

Private Function Precedence(op As String) As Long
    Select Case op
        Case "+", "-": Precedence = 1
        Case "*", "/": Precedence = 2
        Case Else:     Precedence = 0
    End Select
End Function

Private Sub ApplyOp(ByRef nums() As Double, ByRef nTop As Long, ByRef ops() As String, ByRef oTop As Long)
    If nTop < 2 Or oTop = 0 Then Exit Sub
    Dim b As Double, a As Double, op As String, res As Double
    b = nums(nTop): nTop = nTop - 1
    a = nums(nTop): nTop = nTop - 1
    op = ops(oTop): oTop = oTop - 1
    Select Case op
        Case "+": res = a + b
        Case "-": res = a - b
        Case "*": res = a * b
        Case "/": If b = 0 Then res = 0 Else res = a / b
    End Select
    nTop = nTop + 1: ReDim Preserve nums(1 To nTop): nums(nTop) = res
End Sub