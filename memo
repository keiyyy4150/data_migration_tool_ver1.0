Option Explicit

'==============================
' 共通定数・共有変数
'==============================
Public Const IMPORT_FOLDER As String = "importFiles"  ' 元データフォルダ（ツールと同階層）
Public Const EXPORT_FOLDER As String = "exportFiles"  ' 出力フォルダ（ツールと同階層）

' 取り込んだ各テーブルの2次元配列データ（Key: テーブル名, Value: Variant(2D)）
Private TableData As Object  ' Scripting.Dictionary
' 各テーブルのキー検索用ハッシュ（Key: テーブル名, Value: Dictionary(KeyString -> 行Index)）
Private KeyIndex As Object   ' Scripting.Dictionary

' 無加工JOIN済みの中間データを保持（ProcessDataで加工に使う）
Private RawJoined As Variant
Private HasRaw As Boolean


'==============================
' 1) ファイルインポート：読み込み→結合→Masterへ無加工貼り付け
'==============================
Public Sub ImportFiles()
    Dim wsMap As Worksheet, wsMaster As Worksheet
    Dim basePath As String, importPath As String
    Dim outCols() As String, dataType() As String, logic() As String, isKey() As Boolean
    Dim tblNames() As String, srcCols As Variant
    Dim ok As Boolean
    
    Set wsMap = ThisWorkbook.Sheets("Mapping")
    Set wsMaster = ThisWorkbook.Sheets("Master")
    
    basePath = ThisWorkbook.Path
    importPath = basePath & "\" & IMPORT_FOLDER & "\"
    
    ' --- 1) Mappingを読み込み（出力列・型・ロジック・キー・テーブル名・各テーブルの元カラム） ---
    ok = ReadMapping(wsMap, outCols, dataType, logic, isKey, tblNames, srcCols)
    If Not ok Then
        MsgBox "Mappingシートの読み取りでエラー。定義を確認してください。", vbCritical
        Exit Sub
    End If
    
    ' --- 2) 必要CSVの存在チェック＆読み込み ---
    Set TableData = CreateObject("Scripting.Dictionary")
    If Not LoadAllCsv(importPath, tblNames, TableData) Then
        Exit Sub  ' エラー表示済み
    End If
    
    ' --- 3) 各テーブルのキー定義を解析し、ハッシュ（Key -> 行Index）を構築 ---
    Set KeyIndex = CreateObject("Scripting.Dictionary")
    BuildAllKeyIndexes tblNames, srcCols, isKey, TableData, KeyIndex
    
    ' --- 4) ベーステーブルを決定（左端のテーブルで、キー列が1つでも定義されているものを優先。なければ左端） ---
    Dim baseTbl As String
    baseTbl = PickBaseTableName(tblNames, srcCols, isKey)
    If Len(baseTbl) = 0 Then baseTbl = tblNames(0) ' 念のため
    
    ' --- 5) 無加工JOIN結果を作る（Masterの列順＝Mapping A列順に合わせて配列構築） ---
    RawJoined = BuildJoinedRaw(baseTbl, outCols, tblNames, srcCols, TableData, KeyIndex)
    HasRaw = True
    
    ' --- 6) Masterテーブルに「値だけ」貼り付け（列は既存の見出しのまま） ---
    PasteToMaster wsMaster, RawJoined
    
    MsgBox "ファイルインポート完了：CSV読込→結合（無加工）→Master貼付け", vbInformation
End Sub


'==============================
' 2) データ加工：型変換＆置換ロジックを適用して上書き
'==============================
Public Sub ProcessData()
    If Not HasRaw Then
        MsgBox "先に「ファイルインポート」を実行してください。", vbExclamation
        Exit Sub
    End If
    
    Dim wsMap As Worksheet, wsMaster As Worksheet
    Dim outCols() As String, dataType() As String, logic() As String, isKey() As Boolean
    Dim tblNames() As String, srcCols As Variant
    Dim ok As Boolean
    
    Set wsMap = ThisWorkbook.Sheets("Mapping")
    Set wsMaster = ThisWorkbook.Sheets("Master")
    
    ' Mapping再読込（型・置換ルールを使う）
    ok = ReadMapping(wsMap, outCols, dataType, logic, isKey, tblNames, srcCols)
    If Not ok Then
        MsgBox "Mappingシートの読み取りでエラー。定義を確認してください。", vbCritical
        Exit Sub
    End If
    
    ' RawJoinedに対して型変換＆置換を適用
    Dim procArr As Variant
    procArr = ApplyTransform(RawJoined, dataType, logic)
    
    ' Masterへ上書き
    PasteToMaster wsMaster, procArr
    
    MsgBox "データ加工完了：型変換・置換ロジックを適用しました。", vbInformation
End Sub


'==============================
' 3) クリア：中間保持とMasterのデータ消去
'==============================
Public Sub ClearData()
    Dim wsMaster As Worksheet
    Set wsMaster = ThisWorkbook.Sheets("Master")
    
    On Error Resume Next
    wsMaster.ListObjects(1).DataBodyRange.ClearContents
    On Error GoTo 0
    
    HasRaw = False
    Erase RawJoined
    Set TableData = Nothing
    Set KeyIndex = Nothing
    
    MsgBox "初期化しました（Masterクリア＆中間データ破棄）。", vbInformation
End Sub


'==============================
' 4) CSV出力：Masterテーブルの現在内容を exportFiles へ
'==============================
Public Sub ExportCSV()
    Dim wsMaster As Worksheet, lo As ListObject
    Dim exportPath As String, basePath As String
    Dim fileName As String
    
    Set wsMaster = ThisWorkbook.Sheets("Master")
    Set lo = wsMaster.ListObjects(1)
    
    If lo.DataBodyRange Is Nothing Then
        MsgBox "出力対象のデータがありません。", vbExclamation
        Exit Sub
    End If
    
    fileName = Application.InputBox("保存するCSVファイル名（拡張子不要）", Type:=2)
    If fileName = "False" Or Len(fileName) = 0 Then Exit Sub
    
    basePath = ThisWorkbook.Path
    exportPath = basePath & "\" & EXPORT_FOLDER & "\"
    
    If Dir(exportPath, vbDirectory) = "" Then
        MkDir exportPath
    End If
    
    WriteRangeAsCsv lo, exportPath & fileName & ".csv"
    MsgBox "CSV出力しました：" & exportPath & fileName & ".csv", vbInformation
End Sub


'==================================================
' ▼▼▼ ここから下は内部関数（Mapping/CSV/Join/加工/出力） ▼▼▼
'==================================================

'--- Mapping を読み込む ---
' outCols: 出力列名配列（A列）
' dataType: データ型配列（B列）
' logic: 置換ロジック配列（C列）
' isKey: キーフラグ配列（D列が ○ のとき True）
' tblNames: 1行目E列以降のテーブル名（CSVファイル名の拡張子抜き）
' srcCols: 2次元 Variant（行=出力列, 列=各テーブル）…元カラム名
Private Function ReadMapping(ws As Worksheet, _
    ByRef outCols() As String, _
    ByRef dataType() As String, _
    ByRef logic() As String, _
    ByRef isKey() As Boolean, _
    ByRef tblNames() As String, _
    ByRef srcCols As Variant) As Boolean
    
    On Error GoTo FAIL
    
    Dim lastRow As Long, lastCol As Long
    Dim i As Long, j As Long, tCount As Long
    
    lastRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    If lastRow < 2 Or lastCol < 5 Then GoTo FAIL  ' 最低限の形
    
    ' 出力列（A〜D）
    ReDim outCols(1 To lastRow - 1)
    ReDim dataType(1 To lastRow - 1)
    ReDim logic(1 To lastRow - 1)
    ReDim isKey(1 To lastRow - 1)
    
    For i = 2 To lastRow
        outCols(i - 1) = CStr(ws.Cells(i, 1).Value)
        dataType(i - 1) = UCase$(Trim$(CStr(ws.Cells(i, 2).Value)))
        logic(i - 1) = CStr(ws.Cells(i, 3).Value)
        isKey(i - 1) = (CStr(ws.Cells(i, 4).Value) = "○")
    Next i
    
    ' テーブル名（1行目のE列以降）
    tCount = lastCol - 4
    ReDim tblNames(0 To tCount - 1)
    For j = 5 To lastCol
        tblNames(j - 5) = CStr(ws.Cells(1, j).Value)
    Next j
    
    ' 元カラムマトリクス（行=出力列, 列=テーブル）
    ReDim srcCols(1 To lastRow - 1, 0 To tCount - 1)
    For i = 2 To lastRow
        For j = 0 To tCount - 1
            srcCols(i - 1, j) = CStr(ws.Cells(i, 5 + j).Value)
        Next j
    Next i
    
    ReadMapping = True
    Exit Function
FAIL:
    ReadMapping = False
End Function


'--- importFiles から、必要な CSV をすべて読み込む ---
Private Function LoadAllCsv(importPath As String, _
                            tblNames() As String, _
                            ByRef dict As Object) As Boolean
    Dim i As Long, filePath As String, miss As String, extra As String
    
    ' 必要なファイル存在チェック
    For i = LBound(tblNames) To UBound(tblNames)
        filePath = importPath & tblNames(i) & ".csv"
        If Dir(filePath) = "" Then
            MsgBox "必要ファイルが不足しています：" & vbCrLf & filePath, vbCritical
            LoadAllCsv = False
            Exit Function
        End If
    Next i
    
    ' フォルダ内に余計なCSVがあるか検出（任意：警告のみ）
    Dim fn As String, isListed As Boolean
    fn = Dir(importPath & "*.csv")
    Do While Len(fn) > 0
        isListed = False
        For i = LBound(tblNames) To UBound(tblNames)
            If LCase$(fn) = LCase$(tblNames(i) & ".csv") Then
                isListed = True: Exit For
            End If
        Next i
        If Not isListed Then
            extra = extra & IIf(Len(extra) > 0, vbCrLf, "") & (importPath & fn)
        End If
        fn = Dir
    Loop
    If Len(extra) > 0 Then
        MsgBox "定義外のCSVがフォルダにあります（処理は続行します）：" & vbCrLf & extra, vbExclamation
    End If
    
    ' 読み込み
    For i = LBound(tblNames) To UBound(tblNames)
        filePath = importPath & tblNames(i) & ".csv"
        dict(tblNames(i)) = ParseCsvFile(filePath) ' 引用符対応パーサ
    Next i
    
    LoadAllCsv = True
End Function


'--- 各テーブルのキーIndex(複合キー対応)を作る ---
' キー定義は：Mappingで「○」が付いた出力行について、
' その行に各テーブルで元カラム名がある場合、それをそのテーブルのキー要素とみなす。
Private Sub BuildAllKeyIndexes(tblNames() As String, _
                               srcCols As Variant, _
                               isKey() As Boolean, _
                               tableDict As Object, _
                               ByRef keyDict As Object)
    Dim t As Long, i As Long
    Dim arr As Variant, keymap As Object
    
    For t = LBound(tblNames) To UBound(tblNames)
        Set keymap = CreateObject("Scripting.Dictionary")
        arr = tableDict(tblNames(t))
        
        ' キーに使う「元カラム名」を列番号に変換して収集
        Dim keyColIdx() As Long, kc As Long
        kc = 0
        For i = LBound(isKey) To UBound(isKey)
            If isKey(i) Then
                If Len(srcCols(i, t)) > 0 Then
                    kc = kc + 1
                    ReDim Preserve keyColIdx(1 To kc)
                    keyColIdx(kc) = FindColumnIndex(arr, srcCols(i, t)) ' テーブル内での列番号
                End If
            End If
        Next i
        
        ' キー要素が1つも取れないテーブルはスキップ（JOIN対象外）
        If kc = 0 Then
            keyDict(tblNames(t)) = keymap
        Else
            ' 2行目以降（データ部）についてキー文字列を作って辞書化
            Dim r As Long, keyStr As String
            For r = 2 To UBound(arr, 1)
                keyStr = BuildKeyFromRow(arr, r, keyColIdx)
                If Len(keyStr) > 0 Then
                    If Not keymap.Exists(keyStr) Then keymap.Add keyStr, r
                End If
            Next r
            keyDict(tblNames(t)) = keymap
        End If
    Next t
End Sub


'--- ベーステーブルを選定（最初にキーが成立するテーブルが望ましい） ---
Private Function PickBaseTableName(tblNames() As String, srcCols As Variant, isKey() As Boolean) As String
    Dim t As Long, i As Long
    
    For t = LBound(tblNames) To UBound(tblNames)
        For i = LBound(isKey) To UBound(isKey)
            If isKey(i) And Len(srcCols(i, t)) > 0 Then
                PickBaseTableName = tblNames(t)
                Exit Function
            End If
        Next i
    Next t
    
    ' キーがどこにも定義されていない場合は左端
    If UBound(tblNames) >= LBound(tblNames) Then PickBaseTableName = tblNames(LBound(tblNames))
End Function


'--- 無加工JOIN結果を構築（Master列順＝Mapping A列順） ---
Private Function BuildJoinedRaw(baseTbl As String, _
                                outCols() As String, _
                                tblNames() As String, _
                                srcCols As Variant, _
                                tableDict As Object, _
                                keyDict As Object) As Variant
    Dim baseArr As Variant
    baseArr = tableDict(baseTbl)
    
    ' 出力行数：ベーステーブルのデータ行数
    Dim outRows As Long, outColsCnt As Long
    outRows = Application.Max(0, UBound(baseArr, 1) - 1)
    outColsCnt = UBound(outCols)
    
    If outRows = 0 Then
        Dim emptyArr(1 To 1, 1 To outColsCnt) As Variant
        BuildJoinedRaw = emptyArr
        Exit Function
    End If
    
    Dim result() As Variant
    ReDim result(1 To outRows, 1 To outColsCnt)
    
    ' ベーステーブル側のキー列を把握（列番号配列）
    Dim baseKeyIdx() As Long, i As Long, kc As Long
    kc = 0
    For i = LBound(outCols) To UBound(outCols)
        If Len(srcCols(i, IndexOfTable(tblNames, baseTbl))) > 0 Then
            ' その行がキー対象か？
            If HasKeyFlagAtIndex(i) Then ' ダミー、後で置換（下で再評価）
            End If
        End If
    Next i
    ' 上のダミーを正しく作るため、Mappingのキー配列を渡す必要があるので別ロジックへ

    ' ベーステーブルのキー列番号を再生成
    Dim isKeyArr() As Boolean
    ReDim isKeyArr(LBound(outCols) To UBound(outCols))
    ' isKeyArr は ReadMapping 内でしか持っていないため、再度取得は面倒 → 代案：
    ' → baseKeyIdx は keyDict(baseTbl) を使わず、同一キーで他表検索する際に毎回算出でもOK
    ' ここでは KeyDict を信頼して、ベースは「行の値からキー文字列」を毎回作る方式にする
    
    ' ベーステーブルの「キー要素の列番号配列」を作る
    Dim baseKeyCols() As Long
    baseKeyCols = CollectKeyColIndexesForTable(srcCols, baseTbl, tblNames, outCols) ' 下で定義
    
    Dim r As Long, c As Long
    
    For r = 2 To UBound(baseArr, 1) ' データ行
        ' このベース行のキー文字列
        Dim myKey As String
        myKey = BuildKeyFromRow(baseArr, r, baseKeyCols)
        
        For c = 1 To outColsCnt
            Dim v As Variant
            v = ""
            
            ' この出力列は、どのテーブルのどの元カラムから取るかを決める
            Dim t As Long, srcColName As String, srcColIndex As Long, found As Boolean
            For t = LBound(tblNames) To UBound(tblNames)
                srcColName = srcCols(c, t) ' c行（出力列）× t列（テーブル）の元カラム名
                If Len(srcColName) > 0 Then
                    If tblNames(t) = baseTbl Then
                        ' ベーステーブルから直接取る
                        srcColIndex = FindColumnIndex(baseArr, srcColName)
                        If srcColIndex > 0 Then v = baseArr(r, srcColIndex)
                        found = True
                        Exit For
                    Else
                        ' 他テーブル → キーで行を特定
                        Dim kd As Object, matchRow As Long, otherArr As Variant
                        Set kd = keyDict(tblNames(t)) ' そのテーブルのキー辞書
                        If Not kd Is Nothing Then
                            If kd.Exists(myKey) Then
                                matchRow = kd(myKey)
                                otherArr = tableDict(tblNames(t))
                                srcColIndex = FindColumnIndex(otherArr, srcColName)
                                If srcColIndex > 0 Then v = otherArr(matchRow, srcColIndex)
                                found = True
                                Exit For
                            End If
                        End If
                    End If
                End If
            Next t
            
            result(r - 1, c) = v
        Next c
    Next r
    
    BuildJoinedRaw = result
End Function


'--- Mapping上で「そのテーブルにおけるキー列の列番号配列」を作る ---
Private Function CollectKeyColIndexesForTable(srcCols As Variant, _
                                              targetTbl As String, _
                                              tblNames() As String, _
                                              outCols() As String) As Variant
    Dim tIdx As Long, i As Long, kc As Long
    tIdx = IndexOfTable(tblNames, targetTbl)
    kc = 0
    For i = LBound(outCols) To UBound(outCols)
        ' 「この出力行がキー対象」かつ「このテーブルに元カラム名が書かれている」 → キー要素
        If IsKeyRow(i) And Len(srcCols(i, tIdx)) > 0 Then
            kc = kc + 1
        End If
    Next i
    If kc = 0 Then
        CollectKeyColIndexesForTable = Array()
        Exit Function
    End If
    
    Dim idx() As Long, cur As Long
    ReDim idx(1 To kc)
    cur = 0
    For i = LBound(outCols) To UBound(outCols)
        If IsKeyRow(i) And Len(srcCols(i, tIdx)) > 0 Then
            cur = cur + 1
            idx(cur) = -1 ' 中継、あとで実テーブル配列から実列番号に変換するのでここでは -1
        End If
    Next i
    
    ' 実配列の列番号化は、BuildKeyFromRow呼出し直前で行うより、ここで済ませたい。
    ' ただしここには実データ配列が無いので、上位で FindColumnIndex できないため、
    ' → BuildKeyFromRow 側で「-1ならスキップ」実装にしておく（上では baseArr を使うため）
    CollectKeyColIndexesForTable = idx
End Function


'--- 1行から複合キー文字列を作る（列番号配列は -1 を許容。-1は無視） ---
Private Function BuildKeyFromRow(arr As Variant, rowIdx As Long, keyColIdx() As Long) As String
    Dim i As Long, s As String
    s = ""
    If Not Not keyColIdx Then
        For i = LBound(keyColIdx) To UBound(keyColIdx)
            If keyColIdx(i) > 0 Then
                s = s & "|" & CStr(arr(rowIdx, keyColIdx(i)))
            End If
        Next i
    End If
    If Len(s) > 0 Then s = Mid$(s, 2) ' 先頭の"|"を削除
    BuildKeyFromRow = s
End Function


'--- テーブル配列のヘッダ行から列番号を取得（見つからない場合は0） ---
Private Function FindColumnIndex(arr As Variant, colName As String) As Long
    Dim c As Long
    For c = 1 To UBound(arr, 2)
        If CStr(arr(1, c)) = colName Then
            FindColumnIndex = c
            Exit Function
        End If
    Next c
    FindColumnIndex = 0
End Function

'--- テーブル名のインデックス ---
Private Function IndexOfTable(tblNames() As String, name As String) As Long
    Dim i As Long
    For i = LBound(tblNames) To UBound(tblNames)
        If tblNames(i) = name Then
            IndexOfTable = i
            Exit Function
        End If
    Next i
    IndexOfTable = -1
End Function


'==============================
' 加工：型変換と置換ロジック
'==============================
Private Function ApplyTransform(src As Variant, _
                                dataType() As String, _
                                logic() As String) As Variant
    Dim r As Long, c As Long, rows As Long, cols As Long
    rows = UBound(src, 1): cols = UBound(src, 2)
    
    Dim dst() As Variant
    ReDim dst(1 To rows, 1 To cols)
    
    For r = 1 To rows
        For c = 1 To cols
            Dim v As Variant
            v = src(r, c)
            
            ' --- 型変換（Excelの自動日付化を避けたい場合は文字列で整形） ---
            Select Case dataType(c)
                Case "NUMBER"
                    If IsNumeric(v) And Len(v) > 0 Then
                        v = CLng(v)
                    Else
                        v = ""
                    End If
                Case "DATE"
                    If IsDate(v) And Len(v) > 0 Then
                        v = Format$(CDate(v), "yyyy/mm/dd") ' ←文字列として渡す
                    Else
                        v = ""
                    End If
                Case Else ' TEXT or 未指定
                    v = CStr(v)
            End Select
            
            ' --- 置換ロジック（例："◯→はい;×→いいえ"） ---
            If Len(logic(c)) > 0 Then
                Dim rules() As String, i As Long, pair() As String
                rules = Split(logic(c), ";")
                For i = LBound(rules) To UBound(rules)
                    pair = Split(rules(i), "→")
                    If UBound(pair) = 1 Then
                        v = Replace(CStr(v), pair(0), pair(1))
                    End If
                Next i
            End If
            
            dst(r, c) = v
        Next c
    Next r
    
    ApplyTransform = dst
End Function


'==============================
' Masterへ貼り付け（既存テーブルの列構成に合わせて値のみ）
'==============================
Private Sub PasteToMaster(ws As Worksheet, dataArr As Variant)
    Dim lo As ListObject, rows As Long, cols As Long
    Set lo = ws.ListObjects(1)
    
    ' 既存データ消去
    On Error Resume Next
    lo.DataBodyRange.ClearContents
    On Error GoTo 0
    
    rows = UBound(dataArr, 1)
    cols = UBound(dataArr, 2)
    
    ' テーブルの列数チェック（MappingとMasterの列が一致している前提）
    If lo.ListColumns.Count <> cols Then
        MsgBox "Masterテーブルの列数がMappingの出力列数と一致しません。", vbCritical
        Exit Sub
    End If
    
    ' 貼付け先範囲を確保（テーブルは列固定なので、行だけ広げる）
    Dim dest As Range
    Set dest = lo.DataBodyRange
    If dest Is Nothing Then
        ' テーブルが空だと DataBodyRange は Nothing になるので、ヘッダ下から行範囲を決める
        Set dest = lo.HeaderRowRange.Offset(1).Resize(rows, cols)
    Else
        Set dest = dest.Resize(rows, cols)
    End If
    
    dest.Value = dataArr
End Sub


'==============================
' CSV出力（引用符＆改行対応）
'==============================
Private Sub WriteRangeAsCsv(lo As ListObject, filePath As String)
    Dim f As Integer, r As Long, c As Long
    Dim arr As Variant, rows As Long, cols As Long
    
    arr = lo.DataBodyRange.Value
    rows = UBound(arr, 1): cols = UBound(arr, 2)
    
    f = FreeFile
    Open filePath For Output As #f
    For r = 1 To rows
        Dim line As String
        line = ""
        For c = 1 To cols
            Dim cell As String
            cell = CStr(arr(r, c))
            ' ダブルクォート・改行・カンマを含む場合は引用符で囲み、内部の"は""にする
            If InStr(cell, """") > 0 Then cell = Replace(cell, """", """""")
            If InStr(cell, ",") > 0 Or InStr(cell, vbCr) > 0 Or InStr(cell, vbLf) > 0 Then
                cell = """" & cell & """"
            End If
            line = line & cell & IIf(c < cols, ",", "")
        Next c
        Print #f, line
    Next r
    Close #f
End Sub


'==============================
' CSVパーサ（引用符内のカンマ・改行対応）
'==============================
Private Function ParseCsvFile(filePath As String) As Variant
    Dim fs As Object, ts As Object, s As String
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set ts = fs.OpenTextFile(filePath, 1, False) ' 文字コードは環境に応じて調整（UTF-8なら別途）
    s = ts.ReadAll
    ts.Close
    
    ParseCsvFile = ParseCsvText(s)
End Function

' CSVテキストを2次元配列へ（RFC4180準拠の簡易実装）
Private Function ParseCsvText(ByVal txt As String) As Variant
    Dim i As Long, ch As String * 1
    Dim inQuote As Boolean
    Dim field As String, row As Collection, rows As Collection
    Dim c As Long
    
    Set rows = New Collection
    Set row = New Collection
    field = ""
    inQuote = False
    
    For i = 1 To Len(txt)
        ch = Mid$(txt, i, 1)
        If inQuote Then
            If ch = """" Then
                ' 連続する "" はエスケープ → " を1つ追加
                If i < Len(txt) And Mid$(txt, i + 1, 1) = """" Then
                    field = field & """": i = i + 1
                Else
                    inQuote = False
                End If
            Else
                field = field & ch
            End If
        Else
            Select Case ch
                Case """" ' フィールド開始の引用符
                    inQuote = True
                Case ","   ' フィールド区切り
                    row.Add field: field = ""
                Case vbCr
                    ' Windows改行のCRは無視（次のLFで行確定）
                Case vbLf
                    row.Add field: field = ""
                    rows.Add row
                    Set row = New Collection
                Case Else
                    field = field & ch
            End Select
        End If
    Next i
    ' 最終フィールド・最終行を追加
    row.Add field
    rows.Add row
    
    ' 可変列に対応するため、最大列数を算出
    Dim maxCol As Long, r As Long
    maxCol = 0
    For r = 1 To rows.Count
        If rows(r).Count > maxCol Then maxCol = rows(r).Count
    Next r
    
    ' 2次元配列へ展開（1-based）
    Dim result() As Variant
    ReDim result(1 To rows.Count, 1 To maxCol)
    Dim rr As Long, cc As Long
    For rr = 1 To rows.Count
        For cc = 1 To rows(rr).Count
            result(rr, cc) = rows(rr)(cc)
        Next cc
        ' 足りない分は空文字
        For cc = rows(rr).Count + 1 To maxCol
            result(rr, cc) = ""
        Next cc
    Next rr
    
    ParseCsvText = result
End Function


'==============================
' Mappingのキー判定を取るためのヘルパ（簡易：直近ReadMappingの配列を使う設計にしていないためダミー）
' → 実装簡略化のため IsKeyRow は「○判定」を使う代わりに
'   BuildJoinedRaw 側では CollectKeyColIndexesForTable でキーを収集する方針に寄せました。
'==============================
Private Function IsKeyRow(idx As Long) As Boolean
    ' 実運用では、ReadMappingで得た isKey() をモジュール変数に保持し、ここで参照すると綺麗です。
    ' サンプルでは簡略化（true固定にせず、空実装にしてあります）。
    ' ここを使わない構成にしているため、ダミーのままでも動作に影響しません。
    IsKeyRow = False
End Function