Option Explicit

'==============================
' 共通定数・共有変数
'==============================
Public Const IMPORT_FOLDER As String = "importFiles"  ' 元データフォルダ（ツールと同階層）
Public Const EXPORT_FOLDER As String = "exportFiles"  ' 出力フォルダ（ツールと同階層）

' 取り込んだ各テーブルの2次元配列データ（Key: テーブル名, Value: Variant(2D)）
Private TableData As Object  ' Scripting.Dictionary
' 各テーブルのキー検索用ハッシュ（Key: テーブル名, Value: Dictionary(KeyString -> 行Index)）
Private KeyIndex As Object   ' Scripting.Dictionary

' 無加工JOIN済みの中間データを保持（ProcessDataで加工に使う）
Private RawJoined As Variant
Private HasRaw As Boolean

' 現在のMasterが加工後かどうか（CSVの自動ファイル名に使用）
Public IsProcessed As Boolean

' ---- Mappingキャッシュ（直近読込を保持）----
Private m_outCols()  As String  ' A列：出力カラム名
Private m_dataType() As String  ' B列：データ型（TEXT/NUMBER/DATE）
Private m_logic()    As String  ' C列：置換ロジック（"a→b;c→d"）
Private m_isKey()    As Boolean ' D列：キー列フラグ（○）
Private m_tblNames() As String  ' 1行目E列以降：テーブル名（CSVファイル名の拡張子抜き）
Private m_srcCols    As Variant ' 行=出力列、列=テーブル：元カラム名


'==============================
' 1) ファイルインポート：読み込み→結合→Masterへ無加工貼り付け
'==============================
Public Sub ImportFiles()
    Dim wsMap As Worksheet, wsMaster As Worksheet
    Dim basePath As String, importPath As String
    Dim ok As Boolean
    
    Set wsMap = ThisWorkbook.Sheets("Mapping")
    Set wsMaster = ThisWorkbook.Sheets("Master")
    
    basePath = ThisWorkbook.Path
    importPath = basePath & "\" & IMPORT_FOLDER & "\"
    
    ' --- 1) Mapping読込（記載ルールは下の ReadMapping 参照） ---
    ok = ReadMapping(wsMap)
    If Not ok Then
        MsgBox "Mappingシートの読み取りでエラー。定義を確認してください。", vbCritical
        Exit Sub
    End If
    
    ' --- 2) 必要CSVの存在チェック＆全読込 ---
    Set TableData = CreateObject("Scripting.Dictionary")
    If Not LoadAllCsv(importPath, m_tblNames, TableData) Then
        Exit Sub  ' エラー表示済み
    End If
    
    ' --- 3) 各テーブルのキー辞書（複合キー対応）を構築 ---
    Set KeyIndex = CreateObject("Scripting.Dictionary")
    BuildAllKeyIndexes m_tblNames, m_srcCols, m_isKey, TableData, KeyIndex
    
    ' --- 4) ベーステーブル選定（キーが成立する最初のテーブル。なければ左端） ---
    Dim baseTbl As String
    baseTbl = PickBaseTableName(m_tblNames, m_srcCols, m_isKey)
    If Len(baseTbl) = 0 Then baseTbl = m_tblNames(0)
    
    ' --- 5) 無加工JOIN結果を構築（Master列順＝Mapping A列順） ---
    RawJoined = BuildJoinedRaw(baseTbl)
    HasRaw = True
    IsProcessed = False   ' 無加工の状態
    
    ' --- 6) Masterに貼り付け（既存テーブルの列構成に合わせ、行数だけ調整して値を入れる） ---
    PasteToMaster wsMaster, RawJoined
    
    MsgBox "ファイルインポート完了：CSV読込→結合（無加工）→Master貼付け", vbInformation
End Sub


'==============================
' 2) データ加工：型変換＆置換ロジックを適用して上書き
'==============================
Public Sub ProcessData()
    If Not HasRaw Then
        MsgBox "先に「ファイルインポート」を実行してください。", vbExclamation
        Exit Sub
    End If
    
    Dim wsMap As Worksheet, wsMaster As Worksheet
    Dim ok As Boolean
    
    Set wsMap = ThisWorkbook.Sheets("Mapping")
    Set wsMaster = ThisWorkbook.Sheets("Master")
    
    ' 最新のMapping（型・置換）を再読込（m_* を更新）
    ok = ReadMapping(wsMap)
    If Not ok Then
        MsgBox "Mappingシートの読み取りでエラー。定義を確認してください。", vbCritical
        Exit Sub
    End If
    
    ' 無加工JOIN結果 RawJoined に対して加工適用
    Dim procArr As Variant
    procArr = ApplyTransform(RawJoined, m_dataType, m_logic)
    
    ' Masterへ上書き
    PasteToMaster wsMaster, procArr
    
    IsProcessed = True    ' 加工後
    MsgBox "データ加工完了：型変換・置換ロジックを適用しました。", vbInformation
End Sub


'==============================
' 3) クリア：中間保持とMasterのデータ消去
'==============================
Public Sub ClearData()
    Dim wsMaster As Worksheet
    Set wsMaster = ThisWorkbook.Sheets("Master")
    
    On Error Resume Next
    wsMaster.ListObjects(1).DataBodyRange.ClearContents
    On Error GoTo 0
    
    HasRaw = False
    IsProcessed = False
    Erase RawJoined
    Set TableData = Nothing
    Set KeyIndex = Nothing
    
    MsgBox "初期化しました（Masterクリア＆中間データ破棄）。", vbInformation
End Sub


'==============================
' 4) CSV出力：Masterテーブルの現在内容を exportFiles へ
'    （無加工/加工後 で自動ファイル名を切替）
'==============================
Public Sub ExportCSV()
    Dim wsMaster As Worksheet, lo As ListObject
    Dim exportPath As String, basePath As String
    Dim autoName As String
    
    Set wsMaster = ThisWorkbook.Sheets("Master")
    Set lo = wsMaster.ListObjects(1)
    
    If lo.DataBodyRange Is Nothing Then
        MsgBox "出力対象のデータがありません。", vbExclamation
        Exit Sub
    End If
    
    basePath = ThisWorkbook.Path
    exportPath = basePath & "\" & EXPORT_FOLDER & "\"
    If Dir(exportPath, vbDirectory) = "" Then MkDir exportPath
    
    ' 自動ファイル名：加工状態 + タイムスタンプ
    If IsProcessed Then
        autoName = "export_processed_" & TimeStamp() & ".csv"
    Else
        autoName = "export_raw_" & TimeStamp() & ".csv"
    End If
    
    WriteRangeAsCsv lo, exportPath & autoName
    MsgBox "CSV出力しました：" & exportPath & autoName, vbInformation
End Sub


'==================================================
' ▼▼▼ ここから下は内部関数（Mapping/CSV/Join/加工/出力） ▼▼▼
'==================================================

'--- Mapping を読み込む ---
' 記載ルール：
'  A列：出力カラム名（Masterテーブル見出しと一致）
'  B列：データ型（TEXT/NUMBER/DATE）
'  C列：置換ロジック（"a→b;c→d"）
'  D列：キー列フラグ（○で複合キー可）
'  E列以降：1行目=テーブル名（CSVファイル名の拡張子抜き）、2行目以降=そのテーブルでの元カラム名
Private Function ReadMapping(ws As Worksheet) As Boolean
    On Error GoTo FAIL
    Dim lastRow As Long, lastCol As Long
    Dim i As Long, j As Long, tCount As Long
    
    lastRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    If lastRow < 2 Or lastCol < 5 Then GoTo FAIL  ' 最低限の形
    
    ' A〜D
    ReDim m_outCols(1 To lastRow - 1)
    ReDim m_dataType(1 To lastRow - 1)
    ReDim m_logic(1 To lastRow - 1)
    ReDim m_isKey(1 To lastRow - 1)
    
    For i = 2 To lastRow
        m_outCols(i - 1)  = CStr(ws.Cells(i, 1).Value)
        m_dataType(i - 1) = UCase$(Trim$(CStr(ws.Cells(i, 2).Value)))
        m_logic(i - 1)    = CStr(ws.Cells(i, 3).Value)
        m_isKey(i - 1)    = (CStr(ws.Cells(i, 4).Value) = "○")
    Next i
    
    ' テーブル名（1行目のE列以降）
    tCount = lastCol - 4
    ReDim m_tblNames(0 To tCount - 1)
    For j = 5 To lastCol
        m_tblNames(j - 5) = CStr(ws.Cells(1, j).Value)
    Next j
    
    ' 元カラムマトリクス（行=出力列, 列=テーブル）
    ReDim m_srcCols(1 To lastRow - 1, 0 To tCount - 1)
    For i = 2 To lastRow
        For j = 0 To tCount - 1
            m_srcCols(i - 1, j) = CStr(ws.Cells(i, 5 + j).Value)
        Next j
    Next i
    
    ReadMapping = True
    Exit Function
FAIL:
    ReadMapping = False
End Function


'--- importFiles から、必要な CSV をすべて読み込む ---
Private Function LoadAllCsv(importPath As String, _
                            tblNames() As String, _
                            ByRef dict As Object) As Boolean
    Dim i As Long, filePath As String, extra As String
    
    ' 必要なファイル存在チェック
    For i = LBound(tblNames) To UBound(tblNames)
        filePath = importPath & tblNames(i) & ".csv"
        If Dir(filePath) = "" Then
            MsgBox "必要ファイルが不足しています：" & vbCrLf & filePath, vbCritical
            LoadAllCsv = False
            Exit Function
        End If
    Next i
    
    ' 定義外CSVの警告（処理は続行）
    Dim fn As String, isListed As Boolean
    fn = Dir(importPath & "*.csv")
    Do While Len(fn) > 0
        isListed = False
        For i = LBound(tblNames) To UBound(tblNames)
            If LCase$(fn) = LCase$(tblNames(i) & ".csv") Then
                isListed = True: Exit For
            End If
        Next i
        If Not isListed Then
            extra = extra & IIf(Len(extra) > 0, vbCrLf, "") & (importPath & fn)
        End If
        fn = Dir
    Loop
    If Len(extra) > 0 Then
        MsgBox "定義外のCSVがフォルダにあります（処理は続行します）：" & vbCrLf & extra, vbExclamation
    End If
    
    ' 読み込み（引用符・改行対応のCSVパーサ使用）
    For i = LBound(tblNames) To UBound(tblNames)
        filePath = importPath & tblNames(i) & ".csv"
        dict(tblNames(i)) = ParseCsvFile(filePath)
    Next i
    
    LoadAllCsv = True
End Function


'--- 各テーブルのキーIndex(複合キー対応)を作る ---
' キー定義：Mappingで「○」が付いた出力行について、
' その行に各テーブルで元カラム名がある場合、それをそのテーブルのキー要素とみなす。
Private Sub BuildAllKeyIndexes(tblNames() As String, _
                               srcCols As Variant, _
                               isKey() As Boolean, _
                               tableDict As Object, _
                               ByRef keyDict As Object)
    Dim t As Long, i As Long
    Dim arr As Variant, keymap As Object
    
    For t = LBound(tblNames) To UBound(tblNames)
        Set keymap = CreateObject("Scripting.Dictionary")
        arr = tableDict(tblNames(t))
        
        ' キーに使う「元カラム名」を列番号に変換して収集
        Dim keyColIdx() As Long, kc As Long
        kc = 0
        For i = LBound(isKey) To UBound(isKey)
            If isKey(i) Then
                If Len(srcCols(i, t)) > 0 Then
                    kc = kc + 1
                    ReDim Preserve keyColIdx(1 To kc)
                    keyColIdx(kc) = FindColumnIndex(arr, srcCols(i, t)) ' テーブル内での列番号
                End If
            End If
        Next i
        
        ' キー要素が1つも取れないテーブルは空辞書のまま
        If kc > 0 Then
            Dim r As Long, keyStr As String
            For r = 2 To UBound(arr, 1) ' データ行
                keyStr = BuildKeyFromRow(arr, r, keyColIdx)
                If Len(keyStr) > 0 Then
                    If Not keymap.Exists(keyStr) Then keymap.Add keyStr, r
                End If
            Next r
        End If
        keyDict(tblNames(t)) = keymap
    Next t
End Sub


'--- ベーステーブルを選定（最初にキーが成立するテーブル。なければ左端） ---
Private Function PickBaseTableName(tblNames() As String, srcCols As Variant, isKey() As Boolean) As String
    Dim t As Long, i As Long
    For t = LBound(tblNames) To UBound(tblNames)
        For i = LBound(isKey) To UBound(isKey)
            If isKey(i) And Len(srcCols(i, t)) > 0 Then
                PickBaseTableName = tblNames(t)
                Exit Function
            End If
        Next i
    Next t
    If UBound(tblNames) >= LBound(tblNames) Then PickBaseTableName = tblNames(LBound(tblNames))
End Function


'--- 無加工JOIN結果を構築（Master列順＝Mapping A列順） ---
Private Function BuildJoinedRaw(baseTbl As String) As Variant
    Dim baseArr As Variant
    baseArr = TableData(baseTbl)
    
    Dim outRows As Long, outColsCnt As Long
    outRows = Application.Max(0, UBound(baseArr, 1) - 1) ' ヘッダ除く
    outColsCnt = UBound(m_outCols)
    
    If outRows = 0 Then
        Dim emptyArr(1 To 1, 1 To outColsCnt) As Variant
        BuildJoinedRaw = emptyArr
        Exit Function
    End If
    
    Dim result() As Variant
    ReDim result(1 To outRows, 1 To outColsCnt)
    
    ' ベーステーブルの「キー要素の列番号配列」
    Dim baseKeyCols() As Long
    baseKeyCols = CollectKeyColIndexesForBase(baseArr, baseTbl)
    
    Dim r As Long, c As Long
    For r = 2 To UBound(baseArr, 1) ' データ行
        Dim myKey As String
        myKey = BuildKeyFromRow(baseArr, r, baseKeyCols)
        
        For c = 1 To outColsCnt
            Dim v As Variant: v = ""
            Dim t As Long, srcColName As String, srcColIndex As Long, found As Boolean
            
            For t = LBound(m_tblNames) To UBound(m_tblNames)
                srcColName = m_srcCols(c, t) ' 出力列c × テーブルt の元カラム名
                If Len(srcColName) > 0 Then
                    If m_tblNames(t) = baseTbl Then
                        ' ベーステーブルから直接取る
                        srcColIndex = FindColumnIndex(baseArr, srcColName)
                        If srcColIndex > 0 Then v = baseArr(r, srcColIndex)
                        found = True
                        Exit For
                    Else
                        ' 他テーブル → キーで行を特定して取得
                        Dim kd As Object, matchRow As Long, otherArr As Variant
                        Set kd = KeyIndex(m_tblNames(t))
                        If Not kd Is Nothing Then
                            If kd.Exists(myKey) Then
                                matchRow = kd(myKey)
                                otherArr = TableData(m_tblNames(t))
                                srcColIndex = FindColumnIndex(otherArr, srcColName)
                                If srcColIndex > 0 Then v = otherArr(matchRow, srcColIndex)
                                found = True
                                Exit For
                            End If
                        End If
                    End If
                End If
            Next t
            
            result(r - 1, c) = v
        Next c
    Next r
    
    BuildJoinedRaw = result
End Function


'--- ベーステーブルにおけるキー列の「実列番号配列」を作る ---
Private Function CollectKeyColIndexesForBase(baseArr As Variant, baseTbl As String) As Variant
    Dim tIdx As Long, i As Long, kc As Long
    tIdx = IndexOfTable(m_tblNames, baseTbl)
    
    ' まずキー対象の元カラム名を数える
    kc = 0
    For i = LBound(m_outCols) To UBound(m_outCols)
        If m_isKey(i) And Len(m_srcCols(i, tIdx)) > 0 Then
            kc = kc + 1
        End If
    Next i
    If kc = 0 Then
        CollectKeyColIndexesForBase = Array()
        Exit Function
    End If
    
    ' 実列番号に変換
    Dim idx() As Long, cur As Long
    ReDim idx(1 To kc)
    cur = 0
    For i = LBound(m_outCols) To UBound(m_outCols)
        If m_isKey(i) And Len(m_srcCols(i, tIdx)) > 0 Then
            cur = cur + 1
            idx(cur) = FindColumnIndex(baseArr, m_srcCols(i, tIdx))
        End If
    Next i
    
    CollectKeyColIndexesForBase = idx
End Function


'--- 1行から複合キー文字列を作る（列番号配列を連結。空は無視） ---
Private Function BuildKeyFromRow(arr As Variant, rowIdx As Long, keyColIdx() As Long) As String
    Dim i As Long, s As String
    s = ""
    If Not Not keyColIdx Then
        For i = LBound(keyColIdx) To UBound(keyColIdx)
            If keyColIdx(i) > 0 Then
                s = s & "|" & CStr(arr(rowIdx, keyColIdx(i)))
            End If
        Next i
    End If
    If Len(s) > 0 Then s = Mid$(s, 2) ' 先頭の"|"を削除
    BuildKeyFromRow = s
End Function


'--- テーブル配列のヘッダ行から列番号を取得（見つからない場合は0） ---
Private Function FindColumnIndex(arr As Variant, colName As String) As Long
    Dim c As Long
    For c = 1 To UBound(arr, 2)
        If CStr(arr(1, c)) = colName Then
            FindColumnIndex = c
            Exit Function
        End If
    Next c
    FindColumnIndex = 0
End Function

'--- テーブル名のインデックス ---
Private Function IndexOfTable(tblNames() As String, name As String) As Long
    Dim i As Long
    For i = LBound(tblNames) To UBound(tblNames)
        If tblNames(i) = name Then
            IndexOfTable = i
            Exit Function
        End If
    Next i
    IndexOfTable = -1
End Function


'==============================
' 加工：型変換と置換ロジック
'==============================
Private Function ApplyTransform(src As Variant, _
                                dataType() As String, _
                                logic() As String) As Variant
    Dim r As Long, c As Long, rows As Long, cols As Long
    rows = UBound(src, 1): cols = UBound(src, 2)
    
    Dim dst() As Variant
    ReDim dst(1 To rows, 1 To cols)
    
    For r = 1 To rows
        For c = 1 To cols
            Dim v As Variant
            v = src(r, c)
            
            ' --- 型変換（Excelの勝手な日付型化を避けるため DATEは文字列整形） ---
            Select Case dataType(c)
                Case "NUMBER"
                    If IsNumeric(v) And Len(v) > 0 Then
                        v = CLng(v)
                    Else
                        v = ""
                    End If
                Case "DATE"
                    If IsDate(v) And Len(v) > 0 Then
                        v = Format$(CDate(v), "yyyy/mm/dd") ' ←文字列として書き出し
                    Else
                        v = ""
                    End If
                Case Else ' TEXT or 未指定
                    v = CStr(v)
            End Select
            
            ' --- 置換ロジック（例："◯→はい;×→いいえ"） ---
            If Len(logic(c)) > 0 Then
                Dim rules() As String, i As Long, pair() As String
                rules = Split(logic(c), ";")
                For i = LBound(rules) To UBound(rules)
                    pair = Split(rules(i), "→")
                    If UBound(pair) = 1 Then
                        v = Replace(CStr(v), pair(0), pair(1))
                    End If
                Next i
            End If
            
            dst(r, c) = v
        Next c
    Next r
    
    ApplyTransform = dst
End Function


'==============================
' Masterへ貼り付け（既存テーブル列構成を維持しつつ行数調整）
'==============================
Private Sub PasteToMaster(ws As Worksheet, dataArr As Variant)
    Dim lo As ListObject, rows As Long, cols As Long
    Set lo = ws.ListObjects(1)
    
    rows = UBound(dataArr, 1)
    cols = UBound(dataArr, 2)
    
    ' 列数チェック（Mapping A列の数とMasterテーブル列数が一致している前提）
    If lo.ListColumns.Count <> cols Then
        MsgBox "Masterテーブルの列数がMappingの出力列数と一致しません。", vbCritical
        Exit Sub
    End If
    
    ' テーブル全体の範囲を「ヘッダ + rows行」にリサイズ（列は固定）
    Dim newRange As Range
    Set newRange = lo.HeaderRowRange.Resize(rows + 1, lo.ListColumns.Count)
    lo.Resize newRange
    
    ' 値を書き込み
    lo.DataBodyRange.Value = dataArr
End Sub


'==============================
' CSV出力（引用符＆改行対応）
'==============================
Private Sub WriteRangeAsCsv(lo As ListObject, filePath As String)
    Dim f As Integer, r As Long, c As Long
    Dim arr As Variant, rows As Long, cols As Long
    
    arr = lo.DataBodyRange.Value
    rows = UBound(arr, 1): cols = UBound(arr, 2)
    
    f = FreeFile
    Open filePath For Output As #f
    For r = 1 To rows
        Dim line As String
        line = ""
        For c = 1 To cols
            Dim cell As String
            cell = CStr(arr(r, c))
            ' ダブルクォートは "" にエスケープ。カンマ/改行を含む場合は全体を引用符で囲む
            If InStr(cell, """") > 0 Then cell = Replace(cell, """", """""")
            If InStr(cell, ",") > 0 Or InStr(cell, vbCr) > 0 Or InStr(cell, vbLf) > 0 Then
                cell = """" & cell & """"
            End If
            line = line & cell & IIf(c < cols, ",", "")
        Next c
        Print #f, line
    Next r
    Close #f
End Sub


'==============================
' CSVパーサ（引用符内のカンマ・改行対応 / RFC4180簡易）
'==============================
Private Function ParseCsvFile(filePath As String) As Variant
    Dim fs As Object, ts As Object, s As String
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set ts = fs.OpenTextFile(filePath, 1, False) ' 文字コードは環境に応じて調整（UTF-8の場合は別実装が必要）
    s = ts.ReadAll
    ts.Close
    
    ParseCsvFile = ParseCsvText(s)
End Function

Private Function ParseCsvText(ByVal txt As String) As Variant
    Dim i As Long, ch As String * 1
    Dim inQuote As Boolean
    Dim field As String, row As Collection, rows As Collection
    
    Set rows = New Collection
    Set row = New Collection
    field = ""
    inQuote = False
    
    For i = 1 To Len(txt)
        ch = Mid$(txt, i, 1)
        If inQuote Then