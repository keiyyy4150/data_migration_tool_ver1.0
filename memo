Option Explicit

'==============================
' 共通定数・共有変数
'==============================
Public Const IMPORT_FOLDER As String = "importFiles"  ' 入力フォルダ（ツールと同階層）
Public Const EXPORT_FOLDER As String = "exportFiles"  ' 出力フォルダ（ツールと同階層）
Public Const LOG_FOLDER    As String = "log"          ' ログフォルダ（ツールと同階層）

' 取り込んだ各テーブルの2次元配列データ（Key: テーブル名, Value: Variant(2D)）
Private TableData As Object  ' Scripting.Dictionary
' 各テーブルのキー検索用ハッシュ（Key: テーブル名, Value: Dictionary(KeyString -> 行Index)）
Private KeyIndex As Object   ' Scripting.Dictionary

' 無加工JOIN済みの中間データを保持（ProcessDataで加工に使う）
Private RawJoined As Variant
Private HasRaw As Boolean

' 現在のMasterが加工後かどうか（CSVの自動ファイル名に使用）
Public IsProcessed As Boolean

' ---- Mappingキャッシュ（直近読込を保持）----
Private m_outCols()  As String  ' A列：出力カラム名
Private m_dataType() As String  ' B列：データ型（TEXT/NUMBER/DATE）
Private m_logic()    As String  ' C列：置換ロジック（"a→b;c→d"）
Private m_isKey()    As Boolean ' D列：キー列フラグ（○）
Private m_tblNames() As String  ' 1行目E列以降：テーブル名（CSVファイル名の拡張子抜き）
Private m_srcCols    As Variant ' 行=出力列、列=テーブル：元カラム名

' ---- エンコード設定（AUTO/UTF-8/SHIFT_JIS/UTF-16LE）----
Public CurrentEncodingMode As String  ' 例: "AUTO"（既定）


'==============================
' エンコード選択（ダイアログ）
'==============================
Public Sub ChooseEncoding()
    Dim s As String
    s = InputBox( _
        "読み込み・書き出しに使うエンコードを選択してください。" & vbCrLf & _
        "AUTO / UTF-8 / Shift_JIS / UTF-16LE", _
        "Encoding Mode", IIf(Len(CurrentEncodingMode) = 0, "AUTO", CurrentEncodingMode))
    If s = "False" Then Exit Sub
    s = UCase$(Trim$(s))
    Select Case s
        Case "AUTO", "UTF-8", "UTF8"
            CurrentEncodingMode = IIf(s = "UTF8", "UTF-8", s)
        Case "SHIFT_JIS", "SJIS", "CP932"
            CurrentEncodingMode = "SHIFT_JIS"
        Case "UTF-16LE", "UTF16LE", "UNICODE"
            CurrentEncodingMode = "UTF-16LE"
        Case Else
            MsgBox "不正な指定です。AUTO を採用します。", vbExclamation
            CurrentEncodingMode = "AUTO"
    End Select
    EnsureFolder ThisWorkbook.Path & "\" & LOG_FOLDER & "\"
    WriteLog "INFO", "Encoding set: " & CurrentEncodingMode
    MsgBox "Encoding Mode: " & CurrentEncodingMode, vbInformation
End Sub


'==============================
' 1) ファイルインポート：読み込み→結合→Masterへ無加工貼り付け
'==============================
Public Sub ImportFiles()
    On Error GoTo EH
    Dim wsMap As Worksheet, wsMaster As Worksheet
    Dim basePath As String, importPath As String
    Dim ok As Boolean, tStart As Date
    tStart = Now
    
    If Len(CurrentEncodingMode) = 0 Then CurrentEncodingMode = "AUTO"
    
    Set wsMap = ThisWorkbook.Sheets("Mapping")
    Set wsMaster = ThisWorkbook.Sheets("Master")
    
    basePath = ThisWorkbook.Path
    importPath = basePath & "\" & IMPORT_FOLDER & "\"
    
    EnsureFolder basePath & "\" & LOG_FOLDER & "\"
    WriteLog "INFO", "ImportFiles: start / Encoding=" & CurrentEncodingMode
    
    ' --- 1) Mapping読込（記載ルールは下の ReadMapping 参照） ---
    ok = ReadMapping(wsMap)
    If Not ok Then
        WriteLog "ERROR", "Mapping read failed"
        MsgBox "Mappingシートの読み取りでエラー。定義を確認してください。", vbCritical
        Exit Sub
    End If
    
    ' --- 2) 必要CSVの存在チェック＆全読込 ---
    Set TableData = CreateObject("Scripting.Dictionary")
    If Not LoadAllCsv(importPath, m_tblNames, TableData) Then
        WriteLog "ERROR", "LoadAllCsv failed (missing or read error)"
        Exit Sub  ' エラー表示済み
    End If
    
    ' --- 3) 各テーブルのキー辞書（複合キー対応）を構築 ---
    Set KeyIndex = CreateObject("Scripting.Dictionary")
    BuildAllKeyIndexes m_tblNames, m_srcCols, m_isKey, TableData, KeyIndex
    
    ' --- 4) ベーステーブル選定（キーが成立する最初のテーブル。なければ左端） ---
    Dim baseTbl As String
    baseTbl = PickBaseTableName(m_tblNames, m_srcCols, m_isKey)
    If Len(baseTbl) = 0 Then baseTbl = m_tblNames(0)
    WriteLog "INFO", "BaseTable=" & baseTbl
    
    ' --- 5) 無加工JOIN結果を構築（Master列順＝Mapping A列順） ---
    RawJoined = BuildJoinedRaw(baseTbl)
    HasRaw = True
    IsProcessed = False   ' 無加工の状態
    
    ' --- 6) Masterに貼付（既存テーブルの列構成に合わせ、行数だけ調整して値を入れる） ---
    PasteToMaster wsMaster, RawJoined
    
    WriteLog "INFO", "ImportFiles: done / rows=" & UBound(RawJoined, 1) & " / cols=" & UBound(RawJoined, 2) & " / elapsed=" & Format(Now - tStart, "hh:nn:ss")
    MsgBox "ファイルインポート完了：CSV読込→結合（無加工）→Master貼付け", vbInformation
    Exit Sub
EH:
    WriteLog "ERROR", "ImportFiles error: " & Err.Number & " " & Err.Description
    MsgBox "ImportFilesでエラー: " & Err.Description, vbCritical
End Sub


'==============================
' 2) データ加工：型変換＆置換ロジックを適用して上書き
'==============================
Public Sub ProcessData()
    On Error GoTo EH
    Dim wsMap As Worksheet, wsMaster As Worksheet
    Dim ok As Boolean, tStart As Date
    tStart = Now
    
    If Not HasRaw Then
        MsgBox "先に「ファイルインポート」を実行してください。", vbExclamation
        Exit Sub
    End If
    
    Set wsMap = ThisWorkbook.Sheets("Mapping")
    Set wsMaster = ThisWorkbook.Sheets("Master")
    
    WriteLog "INFO", "ProcessData: start"
    
    ' 最新のMapping（型・置換）を再読込（m_* を更新）
    ok = ReadMapping(wsMap)
    If Not ok Then
        WriteLog "ERROR", "Mapping read failed in ProcessData"
        MsgBox "Mappingシートの読み取りでエラー。定義を確認してください。", vbCritical
        Exit Sub
    End If
    
    ' 無加工JOIN結果 RawJoined に対して加工適用
    Dim procArr As Variant
    procArr = ApplyTransform(RawJoined, m_dataType, m_logic)
    
    ' Masterへ上書き
    PasteToMaster wsMaster, procArr
    IsProcessed = True
    
    WriteLog "INFO", "ProcessData: done / rows=" & UBound(procArr, 1) & " / cols=" & UBound(procArr, 2) & " / elapsed=" & Format(Now - tStart, "hh:nn:ss")
    MsgBox "データ加工完了：型変換・置換ロジックを適用しました。", vbInformation
    Exit Sub
EH:
    WriteLog "ERROR", "ProcessData error: " & Err.Number & " " & Err.Description
    MsgBox "ProcessDataでエラー: " & Err.Description, vbCritical
End Sub


'==============================
' 3) クリア：中間保持とMasterのデータ消去
'==============================
Public Sub ClearData()
    On Error Resume Next
    Dim wsMaster As Worksheet
    Set wsMaster = ThisWorkbook.Sheets("Master")
    
    wsMaster.ListObjects(1).DataBodyRange.ClearContents
    On Error GoTo 0
    
    HasRaw = False
    IsProcessed = False
    Erase RawJoined
    Set TableData = Nothing
    Set KeyIndex = Nothing
    
    WriteLog "INFO", "ClearData: Master cleared & memory freed"
    MsgBox "初期化しました（Masterクリア＆中間データ破棄）。", vbInformation
End Sub


'==============================
' 4) CSV出力：Masterテーブルの現在内容を exportFiles へ
'    （無加工/加工後 で自動ファイル名を切替）
'==============================
Public Sub ExportCSV()
    On Error GoTo EH
    Dim wsMaster As Worksheet, lo As ListObject
    Dim exportPath As String, basePath As String
    Dim autoName As String, tStart As Date
    tStart = Now
    
    Set wsMaster = ThisWorkbook.Sheets("Master")
    Set lo = wsMaster.ListObjects(1)
    
    If lo.DataBodyRange Is Nothing Then
        MsgBox "出力対象のデータがありません。", vbExclamation
        Exit Sub
    End If
    
    basePath = ThisWorkbook.Path
    exportPath = basePath & "\" & EXPORT_FOLDER & "\"
    EnsureFolder exportPath
    EnsureFolder basePath & "\" & LOG_FOLDER & "\"
    
    ' 自動ファイル名：加工状態 + タイムスタンプ
    If IsProcessed Then
        autoName = "export_processed_" & TimeStamp() & ".csv"
    Else
        autoName = "export_raw_" & TimeStamp() & ".csv"
    End If
    
    WriteRangeAsCsvWithEncoding lo, exportPath & autoName, CurrentEncodingMode
    WriteLog "INFO", "ExportCSV: " & exportPath & autoName & " / Encoding=" & CurrentEncodingMode & " / rows=" & lo.DataBodyRange.Rows.Count & " / elapsed=" & Format(Now - tStart, "hh:nn:ss")
    MsgBox "CSV出力しました：" & exportPath & autoName, vbInformation
    Exit Sub
EH:
    WriteLog "ERROR", "ExportCSV error: " & Err.Number & " " & Err.Description
    MsgBox "ExportCSVでエラー: " & Err.Description, vbCritical
End Sub


'==================================================
' ▼▼▼ 内部関数（Mapping/CSV/Join/加工/出力/ログ/エンコード） ▼▼▼
'==================================================

'--- Mapping を読み込む ---
' 記載ルール：
'  A列：出力カラム名（Masterテーブル見出しと一致）
'  B列：データ型（TEXT/NUMBER/DATE）
'  C列：置換ロジック（"a→b;c→d"）
'  D列：キー列フラグ（○で複合キー可）
'  E列以降：1行目=テーブル名（CSVファイル名の拡張子抜き）、2行目以降=そのテーブルでの元カラム名
Private Function ReadMapping(ws As Worksheet) As Boolean
    On Error GoTo FAIL
    Dim lastRow As Long, lastCol As Long
    Dim i As Long, j As Long, tCount As Long
    
    lastRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    If lastRow < 2 Or lastCol < 5 Then GoTo FAIL  ' 最低限の形
    
    ' A〜D
    ReDim m_outCols(1 To lastRow - 1)
    ReDim m_dataType(1 To lastRow - 1)
    ReDim m_logic(1 To lastRow - 1)
    ReDim m_isKey(1 To lastRow - 1)
    
    For i = 2 To lastRow
        m_outCols(i - 1)  = CStr(ws.Cells(i, 1).Value)
        m_dataType(i - 1) = UCase$(Trim$(CStr(ws.Cells(i, 2).Value))))
        m_logic(i - 1)    = CStr(ws.Cells(i, 3).Value)
        m_isKey(i - 1)    = (CStr(ws.Cells(i, 4).Value) = "○")
    Next i
    
    ' テーブル名（1行目のE列以降）
    tCount = lastCol - 4
    ReDim m_tblNames(0 To tCount - 1)
    For j = 5 To lastCol
        m_tblNames(j - 5) = CStr(ws.Cells(1, j).Value)
    Next j
    
    ' 元カラムマトリクス（行=出力列, 列=テーブル）
    ReDim m_srcCols(1 To lastRow - 1, 0 To tCount - 1)
    For i = 2 To lastRow
        For j = 0 To tCount - 1
            m_srcCols(i - 1, j) = CStr(ws.Cells(i, 5 + j).Value)
        Next j
    Next i
    
    ReadMapping = True
    Exit Function
FAIL:
    ReadMapping = False
End Function


'--- importFiles から、必要な CSV をすべて読み込む（エンコード対応） ---
Private Function LoadAllCsv(importPath As String, _
                            tblNames() As String, _
                            ByRef dict As Object) As Boolean
    Dim i As Long, filePath As String, extra As String
    
    ' 必要なファイル存在チェック
    For i = LBound(tblNames) To UBound(tblNames)
        filePath = importPath & tblNames(i) & ".csv"
        If Dir(filePath) = "" Then
            MsgBox "必要ファイルが不足しています：" & vbCrLf & filePath, vbCritical
            LoadAllCsv = False
            Exit Function
        End If
    Next i
    
    ' 定義外CSVの警告（処理は続行）
    Dim fn As String, isListed As Boolean
    fn = Dir(importPath & "*.csv")
    Do While Len(fn) > 0
        isListed = False
        For i = LBound(tblNames) To UBound(tblNames)
            If LCase$(fn) = LCase$(tblNames(i) & ".csv") Then
                isListed = True: Exit For
            End If
        Next i
        If Not isListed Then
            extra = extra & IIf(Len(extra) > 0, vbCrLf, "") & (importPath & fn)
        End If
        fn = Dir
    Loop
    If Len(extra) > 0 Then
        WriteLog "WARN", "Extra CSV exists (ignored):" & vbCrLf & extra
        MsgBox "定義外のCSVがフォルダにあります（処理は続行します）：" & vbCrLf & extra, vbExclamation
    End If
    
    ' 読み込み（引用符・改行対応のCSVパーサ使用）
    For i = LBound(tblNames) To UBound(tblNames)
        filePath = importPath & tblNames(i) & ".csv"
        dict(tblNames(i)) = ParseCsvFile(filePath) ' エンコード対応版
        WriteLog "INFO", "Loaded: " & filePath & " / rows=" & UBound(dict(tblNames(i)), 1)
    Next i
    
    LoadAllCsv = True
End Function


'--- 各テーブルのキーIndex(複合キー対応)を作る ---
Private Sub BuildAllKeyIndexes(tblNames() As String, _
                               srcCols As Variant, _
                               isKey() As Boolean, _
                               tableDict As Object, _
                               ByRef keyDict As Object)
    Dim t As Long, i As Long
    Dim arr As Variant, keymap As Object
    
    For t = LBound(tblNames) To UBound(tblNames)
        Set keymap = CreateObject("Scripting.Dictionary")
        arr = tableDict(tblNames(t))
        
        ' キーに使う「元カラム名」を列番号に変換して収集
        Dim keyColIdx() As Long, kc As Long
        kc = 0
        For i = LBound(isKey) To UBound(isKey)
            If isKey(i) Then
                If Len(srcCols(i, t)) > 0 Then
                    kc = kc + 1
                    ReDim Preserve keyColIdx(1 To kc)
                    keyColIdx(kc) = FindColumnIndex(arr, srcCols(i, t)) ' テーブル内での列番号
                End If
            End If
        Next i
        
        ' キー要素が1つも取れないテーブルは空辞書のまま
        If kc > 0 Then
            Dim r As Long, keyStr As String
            For r = 2 To UBound(arr, 1) ' データ行
                keyStr = BuildKeyFromRow(arr, r, keyColIdx)
                If Len(keyStr) > 0 Then
                    If Not keymap.Exists(keyStr) Then keymap.Add keyStr, r
                End If
            Next r
        End If
        keyDict(tblNames(t)) = keymap
    Next t
End Sub


'--- ベーステーブルを選定（最初にキーが成立するテーブル。なければ左端） ---
Private Function PickBaseTableName(tblNames() As String, srcCols As Variant, isKey() As Boolean) As String
    Dim t As Long, i As Long
    For t = LBound(tblNames) To UBound(tblNames)
        For i = LBound(isKey) To UBound(isKey)
            If isKey(i) And Len(srcCols(i, t)) > 0 Then
                PickBaseTableName = tblNames(t)
                Exit Function
            End If
        Next i
    Next t
    If UBound(tblNames) >= LBound(tblNames) Then PickBaseTableName = tblNames(LBound(tblNames))
End Function


'--- 無加工JOIN結果を構築（Master列順＝Mapping A列順） ---
Private Function BuildJoinedRaw(baseTbl As String) As Variant
    Dim baseArr As Variant
    baseArr = TableData(baseTbl)
    
    Dim outRows As Long, outColsCnt As Long
    outRows = Application.Max(0, UBound(baseArr, 1) - 1) ' ヘッダ除く
    outColsCnt = UBound(m_outCols)
    
    If outRows = 0 Then
        Dim emptyArr(1 To 1, 1 To outColsCnt) As Variant
        BuildJoinedRaw = emptyArr
        Exit Function
    End If
    
    Dim result() As Variant
    ReDim result(1 To outRows, 1 To outColsCnt)
    
    ' ベーステーブルの「キー要素の列番号配列」
    Dim baseKeyCols() As Long
    baseKeyCols = CollectKeyColIndexesForBase(baseArr, baseTbl)
    
    Dim r As Long, c As Long
    For r = 2 To UBound(baseArr, 1) ' データ行
        Dim myKey As String
        myKey = BuildKeyFromRow(baseArr, r, baseKeyCols)
        
        For c = 1 To outColsCnt
            Dim v As Variant: v = ""
            Dim t As Long, srcColName As String, srcColIndex As Long
            
            ' この出力列は、どのテーブルのどの元カラムから取るか（左から優先）
            For t = LBound(m_tblNames) To UBound(m_tblNames)
                srcColName = m_srcCols(c, t) ' 出力列c × テーブルt の元カラム名
                If Len(srcColName) > 0 Then
                    If m_tblNames(t) = baseTbl Then
                        ' ベーステーブルから直接取る
                        srcColIndex = FindColumnIndex(baseArr, srcColName)
                        If srcColIndex > 0 Then v = baseArr(r, srcColIndex)
                        Exit For
                    Else
                        ' 他テーブル → キーで行を特定して取得（あれば補完）
                        Dim kd As Object, matchRow As Long, otherArr As Variant
                        Set kd = KeyIndex(m_tblNames(t))
                        If Not kd Is Nothing Then
                            If kd.Exists(myKey) Then
                                matchRow = kd(myKey)
                                otherArr = TableData(m_tblNames(t))
                                srcColIndex = FindColumnIndex(otherArr, srcColName)
                                If srcColIndex > 0 Then v = otherArr(matchRow, srcColIndex)
                                Exit For
                            End If
                        End If
                    End If
                End If
            Next t
            
            result(r - 1, c) = v
        Next c
    Next r
    
    BuildJoinedRaw = result
End Function


'--- ベーステーブルにおけるキー列の「実列番号配列」を作る ---
Private Function CollectKeyColIndexesForBase(baseArr As Variant, baseTbl As String) As Variant
    Dim tIdx As Long, i As Long, kc As Long
    tIdx = IndexOfTable(m_tblNames, baseTbl)
    
    ' まずキー対象の元カラム名を数える
    kc = 0
    For i = LBound(m_outCols) To UBound(m_outCols)
        If m_isKey(i) And Len(m_srcCols(i, tIdx)) > 0 Then
            kc = kc + 1
        End If
    Next i
    If kc = 0 Then
        CollectKeyColIndexesForBase = Array()
        Exit Function
    End If
    
    ' 実列番号に変換
    Dim idx() As Long, cur As Long
    ReDim idx(1 To kc)
    cur = 0
    For i = LBound(m_outCols) To UBound(m_outCols)
        If m_isKey(i) And Len(m_srcCols(i, tIdx)) > 0 Then
            cur = cur + 1
            idx(cur) = FindColumnIndex(baseArr, m_srcCols(i, tIdx))
        End If
    Next i
    
    CollectKeyColIndexesForBase = idx
End Function


'--- 1行から複合キー文字列を作る（列番号配列を連結。空は無視） ---
Private Function BuildKeyFromRow(arr As Variant, rowIdx As Long, keyColIdx() As Long) As String
    Dim i As Long, s As String
    s = ""
    If Not Not keyColIdx Then
        For i = LBound(keyColIdx) To UBound(keyColIdx)
            If keyColIdx(i) > 0 Then
                s = s & "|" & CStr(arr(rowIdx, keyColIdx(i)))
            End If
        Next i
    End If
    If Len(s) > 0 Then s = Mid$(s, 2) ' 先頭の"|"を削除
    BuildKeyFromRow = s
End Function


'--- テーブル配列のヘッダ行から列番号を取得（見つからない場合は0） ---
Private Function FindColumnIndex(arr As Variant, colName As String) As Long
    Dim c As Long
    For c = 1 To UBound(arr, 2)
        If CStr(arr(1, c)) = colName Then
            FindColumnIndex = c
            Exit Function
        End If
    Next c
    FindColumnIndex = 0
End Function

'--- テーブル名のインデックス ---
Private Function IndexOfTable(tblNames() As String, name As String) As Long
    Dim i As Long
    For i = LBound(tblNames) To UBound(tblNames)
        If tblNames(i) = name Then
            IndexOfTable = i
            Exit Function
        End If
    Next i
    IndexOfTable = -1
End Function


'==============================
' 加工：型変換と置換ロジック
'==============================
Private Function ApplyTransform(src As Variant, _
                                dataType() As String, _
                                logic() As String) As Variant
    Dim r As Long, c As Long, rows As Long, cols As Long
    rows = UBound(src, 1): cols = UBound(src, 2)
    
    Dim dst() As Variant
    ReDim dst(1 To rows, 1 To cols)
    
    For r = 1 To rows
        For c = 1 To cols
            Dim v As Variant
            v = src(r, c)
            
            ' --- 型変換（DATEは"yyyy/mm/dd"の文字列で固定） ---
            Select Case dataType(c)
                Case "NUMBER"
                    If IsNumeric(v) And Len(v) > 0 Then
                        v = CLng(v)
                    Else
                        v = ""
                    End If
                Case "DATE"
                    If IsDate(v) And Len(v) > 0 Then
                        v = Format$(CDate(v), "yyyy/mm/dd")
                    Else
                        v = ""
                    End If
                Case Else ' TEXT or 未指定
                    v = CStr(v)
            End Select
            
            ' --- 置換ロジック（例："◯→はい;×→いいえ"） ---
            If Len(logic(c)) > 0 Then
                Dim rules() As String, i As Long, pair() As String
                rules = Split(logic(c), ";")
                For i = LBound(rules) To UBound(rules)
                    pair = Split(rules(i), "→")
                    If UBound(pair) = 1 Then
                        v = Replace(CStr(v), pair(0), pair(1))
                    End If
                Next i
            End If
            
            dst(r, c) = v
        Next c
    Next r
    
    ApplyTransform = dst
End Function


'==============================
' Masterへ貼り付け（既存テーブル列構成を維持しつつ行数調整）
'==============================
Private Sub PasteToMaster(ws As Worksheet, dataArr As Variant)
    Dim lo As ListObject, rows As Long, cols As Long
    Set lo = ws.ListObjects(1)
    
    rows = UBound(dataArr, 1)
    cols = UBound(dataArr, 2)
    
    ' 列数チェック（Mapping A列の数とMasterテーブル列数が一致している前提）
    If lo.ListColumns.Count <> cols Then
        WriteLog "ERROR", "Master columns mismatch. Master=" & lo.ListColumns.Count & " Mapping=" & cols
        MsgBox "Masterテーブルの列数がMappingの出力列数と一致しません。", vbCritical
        Exit Sub
    End If
    
    ' テーブル全体の範囲を「ヘッダ + rows行」にリサイズ（列は固定）
    Dim newRange As Range
    Set newRange = lo.HeaderRowRange.Resize(rows + 1, lo.ListColumns.Count)
    lo.Resize newRange
    
    ' 値を書き込み
    lo.DataBodyRange.Value = dataArr
End Sub


'==============================
' CSV出力（引用符・改行対応 / エンコード対応）
'==============================
Private Sub WriteRangeAsCsvWithEncoding(lo As ListObject, filePath As String, encMode As String)
    Dim arr As Variant, rows As Long, cols As Long
    Dim sb As String
    Dim r As Long, c As Long
    
    arr = lo.DataBodyRange.Value
    rows = UBound(arr, 1): cols = UBound(arr, 2)
    
    ' テキスト生成（1行ずつ組み立て）
    sb = ""
    For r = 1 To rows
        Dim line As String
        line = ""
        For c = 1 To cols
            Dim cell As String
            cell = CStr(arr(r, c))
            If InStr(cell, """") > 0 Then cell = Replace(cell, """", """""")
            If InStr(cell, ",") > 0 Or InStr(cell, vbCr) > 0 Or InStr(cell, vbLf) > 0 Then
                cell = """" & cell & """"
            End If
            line = line & cell & IIf(c < cols, ",", "")
        Next c
        sb = sb & line & vbCrLf
    Next r
    
    WriteTextFile filePath, sb, encMode
End Sub


'==============================
' CSVパーサ（引用符内のカンマ・改行対応 / RFC4180簡易）
'  + エンコード対応（AUTO=自動判定）
'==============================
Private Function ParseCsvFile(filePath As String) As Variant
    Dim text As String
    text = ReadTextFile(filePath, CurrentEncodingMode) ' AUTO/UTF-8/SHIFT_JIS/UTF-16LE
    
    ParseCsvFile = ParseCsvText(text)
End Function

Private Function ParseCsvText(ByVal txt As String) As Variant
    Dim i As Long, ch As String * 1
    Dim inQuote As Boolean
    Dim field As String, row As Collection, rows As Collection
    
    Set rows = New Collection
    Set row = New Collection
    field = ""
    inQuote = False
    
    For i = 1 To Len(txt)
        ch = Mid$(txt, i, 1)
        If inQuote Then
            If ch = """" Then
                If i < Len(txt) And Mid$(txt, i + 1, 1) = """" Then
                    field = field & """": i = i + 1
                Else
                    inQuote = False
                End If
            Else
                field = field & ch
            End If
        Else
            Select Case ch
                Case """" ' 引用開始
                    inQuote = True
                Case ","   ' フィールド区切り
                    row.Add field: field = ""
                Case vbCr  ' CRは無視（次のLFで行確定）
                Case vbLf  ' 行終端
                    row.Add field: field = ""
                    rows.Add row
                    Set row = New Collection
                Case Else
                    field = field & ch
            End Select
        End If
    Next i
    ' 最終フィールド・最終行
    row.Add field
    rows.Add row
    
    ' 最大列数
    Dim maxCol As Long, r As Long
    maxCol = 0
    For r = 1 To rows.Count
        If rows(r).Count > maxCol Then maxCol = rows(r).Count
    Next r
    
    ' 2次元配列へ（1-based）
    Dim result() As Variant
    ReDim result(1 To rows.Count, 1 To maxCol)
    Dim rr As Long, cc As Long
    For rr = 1 To rows.Count
        For cc = 1 To rows(rr).Count
            result(rr, cc) = rows(rr)(cc)
        Next cc
        For cc = rows(rr).Count + 1 To maxCol
            result(rr, cc) = ""
        Next cc
    Next rr
    
    ParseCsvText = result
End Function


'==============================
' 文字コード：読み込み（ADODB.Stream） + 自動判定
'==============================
Private Function ReadTextFile(filePath As String, encMode As String) As String
    Dim mode As String
    mode = UCase$(encMode)
    If mode = "AUTO" Then mode = DetectEncoding(filePath) ' BOM等で判定（無ければSJIS）
    
    Dim stm As Object ' ADODB.Stream
    Set stm = CreateObject("ADODB.Stream")
    stm.Type = 2 ' text
    Select Case mode
        Case "UTF-8":     stm.Charset = "utf-8"
        Case "UTF-16LE":  stm.Charset = "unicode"   ' UTF-16 LE
        Case "SHIFT_JIS": stm.Charset = "shift_jis"
        Case Else:        stm.Charset = "shift_jis" ' フォールバック
    End Select
    stm.Open
    stm.LoadFromFile filePath
    ReadTextFile = stm.ReadText(-1)
    stm.Close
    Set stm = Nothing
End Function

Private Function DetectEncoding(filePath As String) As String
    ' 簡易BOM判定：UTF-8 BOM (EF BB BF)、UTF-16 LE (FF FE)
    Dim f As Integer, b1 As Byte, b2 As Byte, b3 As Byte
    On Error GoTo FAIL
    f = FreeFile
    Open filePath For Binary As #f
    If LOF(f) >= 2 Then
        Get #f, , b1
        Get #f, , b2
        If b1 = &HEF And b2 = &HBB And LOF(f) >= 3 Then
            Get #f, , b3
            If b3 = &HBF Then DetectEncoding = "UTF-8": Close #f: Exit Function
        ElseIf b1 = &HFF And b2 = &HFE Then
            DetectEncoding = "UTF-16LE": Close #f: Exit Function
        End If
    End If
    Close #f
FAIL:
    If Len(DetectEncoding) = 0 Then DetectEncoding = "SHIFT_JIS" ' 既定
End Function


'==============================
' 文字コード：書き出し（ADODB.Stream） + BOM
'==============================
Private Sub WriteTextFile(filePath As String, ByVal content As String, encMode As String)
    Dim stm As Object ' ADODB.Stream
    Dim mode As String
    mode = UCase$(encMode)
    If mode = "AUTO" Then mode = "UTF-8" ' AUTO時の出力既定はUTF-8（BOMあり）
    
    Set stm = CreateObject("ADODB.Stream")
    stm.Type = 2 ' text
    Select Case mode
        Case "UTF-8":     stm.Charset = "utf-8"
        Case "UTF-16LE":  stm.Charset = "unicode"
        Case "SHIFT_JIS": stm.Charset = "shift_jis"
        Case Else:        stm.Charset = "utf-8"
    End Select
    stm.Open
    stm.WriteText content
    stm.SaveToFile filePath, 2 ' adSaveCreateOverWrite
    stm.Close
    Set stm = Nothing
End Sub


'==============================
' ユーティリティ
'==============================
Private Sub EnsureFolder(pathWithSlash As String)
    If Len(Dir(pathWithSlash, vbDirectory)) = 0 Then MkDir pathWithSlash
End Sub

Private Function TimeStamp() As String
    ' 例：20250818_073112
    TimeStamp = Format(Now, "yyyymmdd_hhnnss")
End Function


'==============================
' ログ（/log/tool_YYYYMMDD.log に追記）
'==============================
Private Sub WriteLog(level As String, message As String)
    On Error Resume Next
    Dim basePath As String, logDir As String, logPath As String
    basePath = ThisWorkbook.Path
    logDir = basePath & "\" & LOG_FOLDER & "\"
    If Len(Dir(logDir, vbDirectory)) = 0 Then MkDir logDir
    logPath = logDir & "tool_" & Format(Date, "yyyymmdd") & ".log"
    
    Dim f As Integer
    f = FreeFile
    Open logPath For Append As #f
    Print #f, Format(Now, "yyyy-mm-dd HH:nn:ss"); " [" & level & "] "; message
    Close #f
    On Error GoTo 0
End Sub