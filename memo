ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼
æœ€æ–°ã‚³ãƒ¼ãƒ‰ã‚’ãƒ™ãƒ¼ã‚¹ã«ã€å‰å›ãŠä¼ãˆã—ãŸã€Œã‚¤ãƒ³ãƒãƒ¼ãƒˆæ™‚ã¯ãƒ¢ãƒ¼ãƒ‰ã‚’ç„¡è¦–ã€ã€ŒIFã®then/elseã§ãƒˆãƒ¼ã‚¯ãƒ³å±•é–‹ã€ãªã©ã‚’åæ˜ ã•ã›ãŸå®Œå…¨ã‚³ãƒ¼ãƒ‰ã‚’æ•´ç†ã—ã¾ã—ãŸã€‚

ä»¥ä¸‹ã‚’ãã®ã¾ã¾è²¼ã‚Šæ›¿ãˆã¦ãã ã•ã„ã€‚

â¸»

ğŸ”¹ modGlobalsï¼ˆè¿½è¨˜ã‚ã‚Šï¼‰

Option Explicit

'==============================
' ã‚°ãƒ­ãƒ¼ãƒãƒ«å®šæ•°ãƒ»å…±æœ‰å¤‰æ•°
'==============================
Public Const IMPORT_FOLDER As String = "importFiles"   ' å…¥åŠ›ãƒ•ã‚©ãƒ«ãƒ€
Public Const EXPORT_FOLDER As String = "exportFiles"   ' å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€
Public Const LOG_FOLDER    As String = "log"           ' ãƒ­ã‚°ãƒ•ã‚©ãƒ«ãƒ€

' ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ï¼ˆAUTO/UTF-8/SHIFT_JIS/UTF-16LEï¼‰
Public CurrentEncodingMode As String

' ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ï¼ˆMain / Listï¼‰
Public CurrentMappingTableName As String
Public CurrentMasterTableName  As String
Public CurrentExportBaseName   As String

' 1å¯¾å¤šã‚’å±•é–‹ã™ã‚‹ã‹ï¼ˆList ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã§ Trueï¼‰
Public AllowOneToMany As Boolean

' èª­ã¿è¾¼ã‚“ã å„ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆCSVï¼‰ã®2æ¬¡å…ƒé…åˆ—ï¼ˆKey: ãƒ†ãƒ¼ãƒ–ãƒ«åï¼‰
Public TableData As Object

' JOIN ç”¨ã®ã‚­ãƒ¼ç´¢å¼•
Public KeyIndexSingle As Object
Public KeyIndexMulti  As Object

' ç„¡åŠ å·¥JOINæ¸ˆã¿ã®ä¸­é–“ãƒ‡ãƒ¼ã‚¿
Public RawJoined As Variant
Public HasRaw As Boolean
Public IsProcessed As Boolean

' Mappingã‚­ãƒ£ãƒƒã‚·ãƒ¥
Public Map_OutCols()  As String
Public Map_DataType() As String
Public Map_IsKey()    As Boolean
Public Map_Mode()     As String
Public Map_Def()      As String
Public Map_TblNames() As String
Public Map_SrcCols    As Variant

' JOINå†æ§‹ç¯‰ã§ä½¿ã†ãƒ™ãƒ¼ã‚¹æƒ…å ±
Public m_baseTblName As String
Public m_baseRowIdx() As Long

'=== è¿½åŠ ï¼šã‚¤ãƒ³ãƒãƒ¼ãƒˆæ™‚ã¯ãƒ¢ãƒ¼ãƒ‰ã‚’ç„¡è¦–ã™ã‚‹ãƒ•ãƒ©ã‚° ===
Public IgnoreModeOnImport As Boolean

'==============================
' å…±é€šé–¢æ•°
'==============================
Public Function TimeStamp() As String
    TimeStamp = Format(Now, "yyyymmddhhmmss")
End Function

Public Function IsArrayInitialized(ByVal v As Variant) As Boolean
    On Error GoTo EH
    If IsArray(v) Then
        Dim lb As Long
        lb = LBound(v, 1)
        IsArrayInitialized = True
        Exit Function
    End If
EH:
    IsArrayInitialized = False
End Function

Public Function IsAllocated_Long(ByRef arr() As Long) As Boolean
    On Error GoTo EH
    Dim lb As Long
    lb = LBound(arr, 1)
    IsAllocated_Long = True
    Exit Function
EH:
    IsAllocated_Long = False
End Function


â¸»

ğŸ”¹ modProcessï¼ˆImportFiles ã®ã¿å·®åˆ†ã‚ã‚Šï¼‰

Public Sub ImportFiles()
    On Error GoTo EH
    Dim tStart As Date: tStart = Now
    
    If Len(CurrentEncodingMode) = 0 Then CurrentEncodingMode = "AUTO"
    If Len(CurrentMappingTableName) = 0 Then UsePipelineMain
    
    Dim ok As Boolean
    ok = ReadMappingFromTableName(CurrentMappingTableName)
    If Not ok Then
        MsgBox "Mapping ã®èª­ã¿å–ã‚Šã«å¤±æ•—ã—ã¾ã—ãŸã€‚", vbCritical
        Exit Sub
    End If
    
    Dim importPath As String: importPath = ThisWorkbook.Path & "\" & IMPORT_FOLDER & "\"
    EnsureFolder ThisWorkbook.Path & "\" & LOG_FOLDER & "\"
    
    Set TableData = CreateObject("Scripting.Dictionary")
    If Not LoadAllCsv(importPath, Map_TblNames, TableData) Then Exit Sub
    
    BuildKeyIndexes
    
    m_baseTblName = PickBaseTableName(Map_TblNames, Map_SrcCols, Map_IsKey)
    If Len(m_baseTblName) = 0 And (Not Not Map_TblNames) <> 0 Then m_baseTblName = Map_TblNames(0)
     
    '=== ã“ã“ã§ãƒ¢ãƒ¼ãƒ‰ã‚’ç„¡è¦–ã—ã¦ç„¡åŠ å·¥JOIN ===
    IgnoreModeOnImport = True
    RawJoined = BuildJoinedRaw(m_baseTblName)
    IgnoreModeOnImport = False
    
    HasRaw = True: IsProcessed = False
    
    Dim masterLo As ListObject
    Set masterLo = GetListObjectByName(CurrentMasterTableName)
    If masterLo Is Nothing Then
        MsgBox "Masterãƒ†ãƒ¼ãƒ–ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: " & CurrentMasterTableName, vbCritical
        Exit Sub
    End If
    PasteToMasterByTable masterLo, RawJoined
    
    MsgBox "ãƒ•ã‚¡ã‚¤ãƒ«ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†ï¼ˆç„¡åŠ å·¥ã‚’Masterã¸åæ˜ ï¼‰", vbInformation
    Exit Sub
EH:
    MsgBox "ImportFilesã§ã‚¨ãƒ©ãƒ¼: " & Err.Description, vbCritical
End Sub


â¸»

ğŸ”¹ modJoinAndEvalï¼ˆæ–°è¦è¿½åŠ ï¼‹å·®ã—æ›¿ãˆï¼‰

è¿½åŠ ï¼šã‚¤ãƒ³ãƒãƒ¼ãƒˆå°‚ç”¨ã®å€¤å–å¾—

Public Function BuildRawValueIgnoringMode(colIndex As Long, baseTbl As String, baseRow As Long, myKey As String, _
                                          Optional matchIndex As Long = 1) As String
    Dim t As Long, acc As String: acc = ""
    For t = LBound(Map_TblNames) To UBound(Map_TblNames)
        Dim names As Collection: Set names = SafeGetSrcColNames(colIndex, t)
        If names.Count = 0 Then GoTo CONT_T
        
        If Map_TblNames(t) = baseTbl Then
            Dim arr As Variant: arr = TableData(baseTbl)
            Dim j As Long, nm As String, ci As Long, v As String
            For j = 1 To names.Count
                nm = names(j)
                If IsNumeric(nm) Then
                    ci = CLng(nm)
                Else
                    ci = FindColumnIndex(arr, nm)
                End If
                If ci > 0 Then
                    v = CStr(arr(baseRow, ci))
                    If Len(v) > 0 Then
                        If Len(acc) = 0 Then acc = v Else acc = acc & vbLf & v
                    End If
                End If
            Next
        Else
            Dim j2 As Long, nm2 As String, got As String
            For j2 = 1 To names.Count
                nm2 = names(j2)
                got = GetValueFromTableMulti(Map_TblNames(t), nm2, myKey, matchIndex)
                If Len(got) > 0 Then
                    If Len(acc) = 0 Then acc = got Else acc = acc & vbLf & got
                End If
            Next
        End If
CONT_T:
    Next
    BuildRawValueIgnoringMode = acc
End Function

å·®ã—æ›¿ãˆï¼šBuildJoinedRaw ã®ä¸­ã®åˆ—ãƒ«ãƒ¼ãƒ—

For c = 1 To outColsCnt
    If IgnoreModeOnImport Then
        result(outRow, c) = BuildRawValueIgnoringMode(c, baseTbl, r, myKey, k)
    Else
        Select Case Map_Mode(c)
            Case "CONCAT"
                result(outRow, c) = BuildConcatRawValue(Map_Def(c), baseTbl, r, myKey, k)
            Case "EXPR"
                result(outRow, c) = EvaluateExpr(Map_Def(c), baseTbl, r, myKey, False, c)
            Case Else
                result(outRow, c) = BuildValueModeRaw(c, baseTbl, r, myKey, k)
        End Select
    End If
Next c

å·®ã—æ›¿ãˆï¼šEvalIFLine ã® then/else è¿”å´éƒ¨åˆ†

If ok Then
    EvalIFLine = ApplyTemplate(thenText, baseTbl, baseRow, myKey, processed, outColIndex)
Else
    EvalIFLine = ApplyTemplate(elseText, baseTbl, baseRow, myKey, processed, outColIndex)
End If


â¸»

âœ… ã“ã‚Œã§ã§ãã‚‹ã“ã¨
	â€¢	ã€Œã‚¤ãƒ³ãƒãƒ¼ãƒˆã€æ™‚ã¯ãƒ¢ãƒ¼ãƒ‰ã‚’ç„¡è¦–ã—ã€Mappingã®Gåˆ—ä»¥é™ã®å…ƒã‚«ãƒ©ãƒ ã‚’ãã®ã¾ã¾æ”¹è¡Œé€£çµã—ã¦Masterã«å‡ºåŠ›ã€‚
	â€¢	ã€Œãƒ‡ãƒ¼ã‚¿åŠ å·¥ã€æ™‚ã¯å¾“æ¥é€šã‚Šãƒ¢ãƒ¼ãƒ‰ï¼ˆVALUE/CONCAT/EXPRï¼‰ã‚’é©ç”¨ã€‚
	â€¢	IFæ–‡ã® then/else ã« {tbl.col} ã‚’å«ã‚ã‚Œã° å®Ÿå€¤å±•é–‹ã•ã‚Œã‚‹ã€‚

â¸»

ğŸ‘‰ ã”å¸Œæœ›ã§ã‚ã‚Œã°ã€ã“ã®ä¿®æ­£ã‚’åæ˜ ã•ã›ãŸ modJoinAndEval ä¸¸ã”ã¨æœ€æ–°ç‰ˆ ã‚’å‡ºåŠ›ã§ãã¾ã™ãŒã€ã„ã‹ãŒã—ã¾ã™ã‹ï¼Ÿ