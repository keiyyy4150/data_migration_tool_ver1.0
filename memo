Option Explicit

'==============================
' 共通定数・共有変数
'==============================
Public Const IMPORT_FOLDER As String = "importFiles"  ' 入力フォルダ（ツールと同階層）
Public Const EXPORT_FOLDER As String = "exportFiles"  ' 出力フォルダ（ツールと同階層）
Public Const LOG_FOLDER    As String = "log"          ' ログフォルダ（ツールと同階層）

' 取り込んだ各テーブルの2次元配列データ（Key: テーブル名, Value: Variant(2D)）
Private TableData As Object  ' Scripting.Dictionary
' 各テーブルのキー検索用ハッシュ（Key: テーブル名, Value: Dictionary(KeyString -> 行Index)）
Private KeyIndex As Object   ' Scripting.Dictionary

' 無加工JOIN済みの中間データ（ProcessDataで加工に使う）
Private RawJoined As Variant
Private HasRaw As Boolean

' 現在のMasterが加工後かどうか（CSVの自動ファイル名に使用）
Public IsProcessed As Boolean

' ---- Mappingキャッシュ（直近読込を保持）----
' A〜D列
Private m_outCols()  As String  ' A: 出力カラム名（Masterテーブル見出しと一致）
Private m_dataType() As String  ' B: データ型（TEXT/NUMBER/DATE）
Private m_logic()    As String  ' C: 置換ロジック（"a→b;c→d"）
Private m_isKey()    As Boolean ' D: キー列フラグ（○）
' E〜F列（拡張）
Private m_mode()     As String  ' E: モード（VALUE/CONCAT/EXPR）
Private m_def()      As String  ' F: 定義（CONCATの列挙 or EXPRの式/テンプレ）
' G列以降
Private m_tblNames() As String  ' 1行目E+?：テーブル名（CSVファイルの拡張子抜き）
Private m_srcCols    As Variant ' 行=出力列, 列=テーブル：元カラム名（VALUE時のみ使用）

' ---- エンコード設定（AUTO/UTF-8/SHIFT_JIS/UTF-16LE）----
Public CurrentEncodingMode As String  ' デフォルト "AUTO"

' ---- JOIN再構築のためのベース情報（加工時に列を作り直すため保持）----
Private m_baseTblName As String        ' ベーステーブル名
Private m_baseRowIdx() As Long         ' 出力行ごとの「ベーステーブルの行Index(2〜)」
                                       ' ※ RawJoinedの1行目はベースの2行目に対応 → BaseRowIdx(1)=2

' ---- マルチパイプライン（A/B等） ----
Public CurrentMappingSheetName As String
Public CurrentMasterSheetName  As String
Public CurrentExportPrefix     As String

'==============================
' 起動時の既定パイプライン
'==============================
Public Sub UseDefaultPipeline()
    CurrentMappingSheetName = "Mapping"
    CurrentMasterSheetName = "Master"
    CurrentExportPrefix = ""
End Sub

Public Sub UsePipelineA()
    CurrentMappingSheetName = "Mapping_A"
    CurrentMasterSheetName = "Master_A"
    CurrentExportPrefix = "A_"
    WriteLog "INFO", "Switched pipeline: A"
End Sub

Public Sub UsePipelineB()
    CurrentMappingSheetName = "Mapping_B"
    CurrentMasterSheetName = "Master_B"
    CurrentExportPrefix = "B_"
    WriteLog "INFO", "Switched pipeline: B"
End Sub

'==============================
' エンコード選択（ダイアログ）
'==============================
Public Sub ChooseEncoding()
    Dim s As String
    s = InputBox( _
        "読み込み・書き出しに使うエンコードを選択してください。" & vbCrLf & _
        "AUTO / UTF-8 / Shift_JIS / UTF-16LE", _
        "Encoding Mode", IIf(Len(CurrentEncodingMode) = 0, "AUTO", CurrentEncodingMode))
    If s = "False" Then Exit Sub
    s = UCase$(Trim$(s))
    Select Case s
        Case "AUTO", "UTF-8", "UTF8"
            CurrentEncodingMode = IIf(s = "UTF8", "UTF-8", s)
        Case "SHIFT_JIS", "SJIS", "CP932"
            CurrentEncodingMode = "SHIFT_JIS"
        Case "UTF-16LE", "UTF16LE", "UNICODE"
            CurrentEncodingMode = "UTF-16LE"
        Case Else
            MsgBox "不正な指定です。AUTO を採用します。", vbExclamation
            CurrentEncodingMode = "AUTO"
    End Select
    EnsureFolder ThisWorkbook.Path & "\" & LOG_FOLDER & "\"
    WriteLog "INFO", "Encoding set: " & CurrentEncodingMode
    MsgBox "Encoding Mode: " & CurrentEncodingMode, vbInformation
End Sub

'==============================
' 1) ファイルインポート：読み込み→結合→Masterへ無加工貼り付け
'==============================
Public Sub ImportFiles()
    On Error GoTo EH
    Dim wsMap As Worksheet, wsMaster As Worksheet
    Dim basePath As String, importPath As String
    Dim ok As Boolean, tStart As Date
    tStart = Now
    
    If Len(CurrentEncodingMode) = 0 Then CurrentEncodingMode = "AUTO"
    If Len(CurrentMappingSheetName) = 0 Then UseDefaultPipeline
    
    Set wsMap = ThisWorkbook.Sheets(CurrentMappingSheetName)
    Set wsMaster = ThisWorkbook.Sheets(CurrentMasterSheetName)
    
    basePath = ThisWorkbook.Path
    importPath = basePath & "\" & IMPORT_FOLDER & "\"
    
    EnsureFolder basePath & "\" & LOG_FOLDER & "\"
    WriteLog "INFO", "ImportFiles: start / Encoding=" & CurrentEncodingMode & " / Mapping=" & CurrentMappingSheetName
    
    ' --- 1) Mapping読込 ---
    ok = ReadMapping(wsMap)
    If Not ok Then
        WriteLog "ERROR", "Mapping read failed"
        MsgBox "Mappingの読み取りでエラー。定義を確認してください。", vbCritical
        Exit Sub
    End If
    
    ' --- 2) 必要CSVの存在チェック＆全読込 ---
    Set TableData = CreateObject("Scripting.Dictionary")
    If Not LoadAllCsv(importPath, m_tblNames, TableData) Then
        WriteLog "ERROR", "LoadAllCsv failed (missing or read error)"
        Exit Sub  ' エラー表示済み
    End If
    
    ' --- 3) 各テーブルのキー辞書（複合キー対応）を構築 ---
    Set KeyIndex = CreateObject("Scripting.Dictionary")
    BuildAllKeyIndexes m_tblNames, m_srcCols, m_isKey, TableData, KeyIndex
    
    ' --- 4) ベーステーブル選定（キーが成立する最初のテーブル。なければ左端） ---
    m_baseTblName = PickBaseTableName(m_tblNames, m_srcCols, m_isKey)
    If Len(m_baseTblName) = 0 Then m_baseTblName = m_tblNames(0)
    WriteLog "INFO", "BaseTable=" & m_baseTblName
    
    ' --- 5) 無加工JOIN結果を構築（VALUE/CONCAT/EXPRをrawで解釈） ---
    RawJoined = BuildJoinedRaw(m_baseTblName)  ' ここで m_baseRowIdx も設定
    HasRaw = True
    IsProcessed = False   ' 無加工の状態
    
    ' --- 6) Masterに貼付（既存テーブルの列構成に合わせ、行数だけ調整して値を入れる） ---
    PasteToMaster wsMaster, RawJoined
    
    WriteLog "INFO", "ImportFiles: done / rows=" & UBound(RawJoined, 1) & " / cols=" & UBound(RawJoined, 2) & " / elapsed=" & Format(Now - tStart, "hh:nn:ss")
    MsgBox "ファイルインポート完了：CSV読込→結合（無加工/CONCAT/EXPR raw）→Master貼付け", vbInformation
    Exit Sub
EH:
    WriteLog "ERROR", "ImportFiles error: " & Err.Number & " " & Err.Description
    MsgBox "ImportFilesでエラー: " & Err.Description, vbCritical
End Sub

'==============================
' 2) データ加工：型変換＆置換ロジック（VALUE/CONCAT/EXPR対応）
'==============================
Public Sub ProcessData()
    On Error GoTo EH
    Dim wsMap As Worksheet, wsMaster As Worksheet
    Dim ok As Boolean, tStart As Date
    tStart = Now
    
    If Not HasRaw Then
        MsgBox "先に『ファイルインポート』を実行してください。", vbExclamation
        Exit Sub
    End If
    If Len(CurrentMappingSheetName) = 0 Then UseDefaultPipeline
    
    Set wsMap = ThisWorkbook.Sheets(CurrentMappingSheetName)
    Set wsMaster = ThisWorkbook.Sheets(CurrentMasterSheetName)
    
    WriteLog "INFO", "ProcessData: start / Mapping=" & CurrentMappingSheetName
    
    ' 最新のMappingを再読込（加工ルール・式を使う）
    ok = ReadMapping(wsMap)
    If Not ok Then
        WriteLog "ERROR", "Mapping read failed in ProcessData"
        MsgBox "Mappingの読み取りでエラー。定義を確認してください。", vbCritical
        Exit Sub
    End If
    
    ' 加工適用（VALUE列は既存処理、CONCAT/EXPRはトークンに加工→再合成）
    Dim procArr As Variant
    procArr = ApplyTransformSmart(RawJoined)
    
    ' Masterへ上書き
    PasteToMaster wsMaster, procArr
    IsProcessed = True
    
    WriteLog "INFO", "ProcessData: done / rows=" & UBound(procArr, 1) & " / cols=" & UBound(procArr, 2) & " / elapsed=" & Format(Now - tStart, "hh:nn:ss")
    MsgBox "データ加工完了：VALUE/CONCAT/EXPRのルールを適用しました。", vbInformation
    Exit Sub
EH:
    WriteLog "ERROR", "ProcessData error: " & Err.Number & " " & Err.Description
    MsgBox "ProcessDataでエラー: " & Err.Description, vbCritical
End Sub

'==============================
' 3) クリア：中間保持とMasterのデータ消去
'==============================
Public Sub ClearData()
    On Error Resume Next
    Dim wsMaster As Worksheet
    If Len(CurrentMasterSheetName) = 0 Then UseDefaultPipeline
    Set wsMaster = ThisWorkbook.Sheets(CurrentMasterSheetName)
    
    wsMaster.ListObjects(1).DataBodyRange.ClearContents
    On Error GoTo 0
    
    HasRaw = False
    IsProcessed = False
    Erase RawJoined
    Erase m_baseRowIdx
    m_baseTblName = ""
    Set TableData = Nothing
    Set KeyIndex = Nothing
    
    WriteLog "INFO", "ClearData: Master cleared & memory freed"
    MsgBox "初期化しました（Masterクリア＆中間データ破棄）。", vbInformation
End Sub

'==============================
' 4) CSV出力：Masterの現在内容を exportFiles へ
'==============================
Public Sub ExportCSV()
    On Error GoTo EH
    Dim wsMaster As Worksheet, lo As ListObject
    Dim exportPath As String, basePath As String
    Dim autoName As String, tStart As Date
    tStart = Now
    
    If Len(CurrentMasterSheetName) = 0 Then UseDefaultPipeline
    Set wsMaster = ThisWorkbook.Sheets(CurrentMasterSheetName)
    Set lo = wsMaster.ListObjects(1)
    
    If lo.DataBodyRange Is Nothing Then
        MsgBox "出力対象のデータがありません。", vbExclamation
        Exit Sub
    End If
    
    basePath = ThisWorkbook.Path
    exportPath = basePath & "\" & EXPORT_FOLDER & "\"
    EnsureFolder exportPath
    EnsureFolder basePath & "\" & LOG_FOLDER & "\"
    
    ' 自動ファイル名：パイプラインPrefix + 加工状態 + タイムスタンプ
    If IsProcessed Then
        autoName = CurrentExportPrefix & "export_processed_" & TimeStamp() & ".csv"
    Else
        autoName = CurrentExportPrefix & "export_raw_" & TimeStamp() & ".csv"
    End If
    
    WriteRangeAsCsvWithEncoding lo, exportPath & autoName, CurrentEncodingMode
    WriteLog "INFO", "ExportCSV: " & exportPath & autoName & " / Encoding=" & CurrentEncodingMode & " / rows=" & lo.DataBodyRange.Rows.Count & " / elapsed=" & Format(Now - tStart, "hh:nn:ss")
    MsgBox "CSV出力しました：" & exportPath & autoName, vbInformation
    Exit Sub
EH:
    WriteLog "ERROR", "ExportCSV error: " & Err.Number & " " & Err.Description
    MsgBox "ExportCSVでエラー: " & Err.Description, vbCritical
End Sub


'==================================================
' ▼▼▼ 内部関数（Mapping/CSV/Join/加工/出力/ログ/エンコード） ▼▼▼
'==================================================

'--- Mapping を読み込む ---
' 記載ルール：
'  A: 出力カラム名（Master見出しと一致）
'  B: データ型（TEXT/NUMBER/DATE） … DATEは最終"yyyy/mm/dd"文字列
'  C: 置換ロジック（"a→b;c→d"）
'  D: キー列フラグ（○で複合可）
'  E: モード（VALUE / CONCAT / EXPR）
'  F: 定義（CONCAT: "T1.c1 | T2.c2 | T3.c3"、EXPR: "{T1.c1}*{T2.c2}-{T3.c3}" or 文字列テンプレ）
'  G以降: VALUEモードで使用する元カラム名（1行目はテーブル名）
Private Function ReadMapping(ws As Worksheet) As Boolean
    On Error GoTo FAIL
    Dim lastRow As Long, lastCol As Long
    Dim i As Long, j As Long, tCount As Long
    
    lastRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    If lastRow < 2 Or lastCol < 5 Then GoTo FAIL  ' 最低限の形
    
    ' A〜F
    ReDim m_outCols(1 To lastRow - 1)
    ReDim m_dataType(1 To lastRow - 1)
    ReDim m_logic(1 To lastRow - 1)
    ReDim m_isKey(1 To lastRow - 1)
    ReDim m_mode(1 To lastRow - 1)
    ReDim m_def(1 To lastRow - 1)
    
    For i = 2 To lastRow
        m_outCols(i - 1)  = CStr(ws.Cells(i, 1).Value)
        m_dataType(i - 1) = UCase$(Trim$(CStr(ws.Cells(i, 2).Value)))
        m_logic(i - 1)    = CStr(ws.Cells(i, 3).Value)
        m_isKey(i - 1)    = (CStr(ws.Cells(i, 4).Value) = "○")
        m_mode(i - 1)     = UCase$(Trim$(CStr(ws.Cells(i, 5).Value)))
        If Len(m_mode(i - 1)) = 0 Then m_mode(i - 1) = "VALUE"
        m_def(i - 1)      = CStr(ws.Cells(i, 6).Value)
    Next i
    
    ' テーブル名（1行目のG列以降）
    tCount = Application.Max(0, lastCol - 6)
    ReDim m_tblNames(0 To IIf(tCount > 0, tCount - 1, 0))
    If tCount > 0 Then
        For j = 7 To lastCol
            m_tblNames(j - 7) = CStr(ws.Cells(1, j).Value)
        Next j
    Else
        ' VALUEモードが一切無い場合もありうる（CONCAT/EXPRのみ）→ m_tblNamesは読み込まない想定OK
    End If
    
    ' 元カラムマトリクス（行=出力列, 列=テーブル）※VALUEモードで使用
    If tCount > 0 Then
        ReDim m_srcCols(1 To lastRow - 1, 0 To tCount - 1)
        For i = 2 To lastRow
            For j = 0 To tCount - 1
                m_srcCols(i - 1, j) = CStr(ws.Cells(i, 7 + j).Value)
            Next j
        Next i
    Else
        ReDim m_srcCols(1 To 1, 0 To 0) ' ダミー
    End If
    
    ReadMapping = True
    Exit Function
FAIL:
    ReadMapping = False
End Function

'--- importFiles から必要CSVを読み込む（エンコード対応） ---
Private Function LoadAllCsv(importPath As String, _
                            tblNames() As String, _
                            ByRef dict As Object) As Boolean
    Dim i As Long, filePath As String, extra As String
    
    ' （CONCAT/EXPRのみのケースではtblNamesが空のこともある）→その場合はフォルダの存在のみ確認
    If (Not Not tblNames) = 0 Then
        If Dir(importPath, vbDirectory) = "" Then
            MsgBox "入力フォルダが存在しません：" & importPath, vbCritical
            LoadAllCsv = False
            Exit Function
        End If
        LoadAllCsv = True
        Exit Function
    End If
    
    ' 必須CSV存在チェック
    For i = LBound(tblNames) To UBound(tblNames)
        filePath = importPath & tblNames(i) & ".csv"
        If Dir(filePath) = "" Then
            MsgBox "必要ファイルが不足しています：" & vbCrLf & filePath, vbCritical
            LoadAllCsv = False
            Exit Function
        End If
    Next i
    
    ' 余分CSVの警告（処理は続行）
    Dim fn As String, isListed As Boolean
    fn = Dir(importPath & "*.csv")
    Do While Len(fn) > 0
        isListed = False
        For i = LBound(tblNames) To UBound(tblNames)
            If LCase$(fn) = LCase$(tblNames(i) & ".csv") Then
                isListed = True: Exit For
            End If
        Next i
        If Not isListed Then
            extra = extra & IIf(Len(extra) > 0, vbCrLf, "") & (importPath & fn)
        End If
        fn = Dir
    Loop
    If Len(extra) > 0 Then
        WriteLog "WARN", "Extra CSV exists (ignored):" & vbCrLf & extra
        MsgBox "定義外のCSVがフォルダにあります（処理は続行します）：" & vbCrLf & extra, vbExclamation
    End If
    
    ' 読み込み
    For i = LBound(tblNames) To UBound(tblNames)
        filePath = importPath & tblNames(i) & ".csv"
        dict(tblNames(i)) = ParseCsvFile(filePath)
        WriteLog "INFO", "Loaded: " & filePath & " / rows=" & UBound(dict(tblNames(i)), 1)
    Next i
    
    LoadAllCsv = True
End Function

'--- 各テーブルのキーIndex(複合キー対応)を作る ---
Private Sub BuildAllKeyIndexes(tblNames() As String, _
                               srcCols As Variant, _
                               isKey() As Boolean, _
                               tableDict As Object, _
                               ByRef keyDict As Object)
    Dim t As Long, i As Long
    Dim arr As Variant, keymap As Object
    
    If (Not Not tblNames) = 0 Then Exit Sub ' テーブル無し（EXPRのみ等）でも安全
    
    For t = LBound(tblNames) To UBound(tblNames)
        Set keymap = CreateObject("Scripting.Dictionary")
        arr = tableDict(tblNames(t))
        
        Dim keyColIdx() As Long, kc As Long
        kc = 0
        For i = LBound(isKey) To UBound(isKey)
            If isKey(i) Then
                If UBound(srcCols, 2) >= t Then
                    If Len(srcCols(i, t)) > 0 Then
                        kc = kc + 1
                        ReDim Preserve keyColIdx(1 To kc)
                        keyColIdx(kc) = FindColumnIndex(arr, srcCols(i, t))
                    End If
                End If
            End If
        Next i
        
        If kc > 0 Then
            Dim r As Long, keyStr As String
            For r = 2 To UBound(arr, 1)
                keyStr = BuildKeyFromRow(arr, r, keyColIdx)
                If Len(keyStr) > 0 Then
                    If Not keymap.Exists(keyStr) Then keymap.Add keyStr, r
                End If
            Next r
        End If
        keyDict(tblNames(t)) = keymap
    Next t
End Sub

'--- ベーステーブルの選定 ---
Private Function PickBaseTableName(tblNames() As String, srcCols As Variant, isKey() As Boolean) As String
    Dim t As Long, i As Long
    If (Not Not tblNames) = 0 Then
        PickBaseTableName = "" ' テーブル不要ケース（EXPRのみ等）
        Exit Function
    End If
    For t = LBound(tblNames) To UBound(tblNames)
        For i = LBound(isKey) To UBound(isKey)
            If isKey(i) Then
                If UBound(srcCols, 2) >= t Then
                    If Len(srcCols(i, t)) > 0 Then
                        PickBaseTableName = tblNames(t)
                        Exit Function
                    End If
                End If
            End If
        Next i
    Next t
    If UBound(tblNames) >= LBound(tblNames) Then PickBaseTableName = tblNames(LBound(tblNames))
End Function

'--- 無加工JOIN結果を構築（VALUE/CONCAT/EXPR を raw で生成） ---
Private Function BuildJoinedRaw(baseTbl As String) As Variant
    Dim outColsCnt As Long: outColsCnt = UBound(m_outCols)
    Dim outRows As Long, result() As Variant
    Dim r As Long, c As Long
    
    Dim baseArr As Variant
    Dim haveBase As Boolean: haveBase = (Len(baseTbl) > 0)
    
    If haveBase Then
        baseArr = TableData(baseTbl)
        outRows = Application.Max(0, UBound(baseArr, 1) - 1) ' ヘッダ除く
        ReDim m_baseRowIdx(1 To outRows)
    Else
        ' ベーステーブルなし（EXPRのみのケース等）は出力行を0にできないので安全策として0行
        outRows = 0
    End If
    
    If outRows = 0 Then
        Dim emptyArr(1 To 1, 1 To outColsCnt) As Variant
        BuildJoinedRaw = emptyArr
        Exit Function
    End If
    
    ReDim result(1 To outRows, 1 To outColsCnt)
    
    Dim baseKeyCols() As Long
    If haveBase Then baseKeyCols = CollectKeyColIndexesForBase(baseArr, baseTbl)
    
    For r = 2 To UBound(baseArr, 1) ' データ行
        Dim myKey As String
        If haveBase Then myKey = BuildKeyFromRow(baseArr, r, baseKeyCols)
        m_baseRowIdx(r - 1) = r
        
        For c = 1 To outColsCnt
            Select Case m_mode(c)
                Case "CONCAT"
                    result(r - 1, c) = BuildConcatRawValue(m_def(c), baseTbl, r, myKey)
                Case "EXPR"
                    result(r - 1, c) = BuildExprRawValue(m_def(c), baseTbl, r, myKey)
                Case Else ' VALUE（既存）
                    result(r - 1, c) = BuildValueModeRaw(c, baseTbl, r, myKey)
            End Select
        Next c
    Next r
    
    BuildJoinedRaw = result
End Function

'--- VALUEモード（優先・補完）raw値取得 ---
Private Function BuildValueModeRaw(colIndex As Long, baseTbl As String, baseRow As Long, myKey As String) As Variant
    Dim t As Long, srcColName As String, srcColIndex As Long, v As Variant
    v = ""
    If (Not Not m_tblNames) = 0 Then Exit Function
    
    For t = LBound(m_tblNames) To UBound(m_tblNames)
        If UBound(m_srcCols, 2) >= t Then
            srcColName = m_srcCols(colIndex, t)
            If Len(srcColName) > 0 Then
                If m_tblNames(t) = baseTbl Then
                    srcColIndex = FindColumnIndex(TableData(baseTbl), srcColName)
                    If srcColIndex > 0 Then v = TableData(baseTbl)(baseRow, srcColIndex)
                    Exit For
                Else
                    Dim kd As Object, matchRow As Long, otherArr As Variant
                    Set kd = KeyIndex(m_tblNames(t))
                    If Not kd Is Nothing Then
                        If kd.Exists(myKey) Then
                            matchRow = kd(myKey)
                            otherArr = TableData(m_tblNames(t))
                            srcColIndex = FindColumnIndex(otherArr, srcColName)
                            If srcColIndex > 0 Then v = otherArr(matchRow, srcColIndex)
                            Exit For
                        End If
                    End If
                End If
            End If
        End If
    Next t
    BuildValueModeRaw = v
End Function

'=== CONCAT 用：F列1アイテムの解析（条件書式対応） =========================
'  形式1: "T.c"                    → token="T.c", hasCond=False
'  形式2: "T.c=◯→文字"            → token="T.c", hasCond=True, cond="◯", label="文字"
Private Sub ParseConcatSpec(ByVal part As String, _
                            ByRef token As String, _
                            ByRef hasCond As Boolean, _
                            ByRef cond As String, _
                            ByRef label As String)
    Dim s As String, posArrow As Long, leftPart As String, posEq As Long
    s = Trim$(part)
    hasCond = False: cond = "": label = "": token = ""
    
    posArrow = InStr(s, "→")
    If posArrow > 0 Then
        leftPart = Trim$(Left$(s, posArrow - 1))     ' "T.c=◯"
        label = Mid$(s, posArrow + Len("→"))         ' "文字"
        posEq = InStr(leftPart, "=")
        If posEq > 0 Then
            token = Trim$(Left$(leftPart, posEq - 1)) ' "T.c"
            cond = Mid$(leftPart, posEq + 1)          ' "◯"
            hasCond = True
        Else
            token = leftPart ' 念のため
        End If
    Else
        token = s
    End If
End Sub

'--- CONCATモード raw値生成（各トークン値を無加工で取得→改行連結 / 条件対応） ---
Private Function BuildConcatRawValue(def As String, baseTbl As String, baseRow As Long, myKey As String) As String
    Dim items() As String, i As Long, spec As String, v As String, acc As String
    Dim token As String, hasCond As Boolean, cond As String, label As String, raw As String
    items = Split(def, "|")
    acc = ""
    For i = LBound(items) To UBound(items)
        spec = Trim$(items(i)) ' 例: "A.col1" or "A.col1=◯→カラム1"
        If Len(spec) = 0 Then GoTo CONTI
        
        ParseConcatSpec spec, token, hasCond, cond, label
        
        If hasCond Then
            raw = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
            If CStr(raw) = cond Then
                v = label
            Else
                v = "" ' スキップ
            End If
        Else
            v = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
        End If
        
        If Len(v) > 0 Then
            If Len(acc) = 0 Then acc = v Else acc = acc & vbLf & v
        End If
CONTI:
    Next
    BuildConcatRawValue = acc
End Function

'--- EXPRモード raw値生成（数式 or テンプレ） ---
Private Function BuildExprRawValue(def As String, baseTbl As String, baseRow As Long, myKey As String) As Variant
    If InStr(def, """") > 0 Then
        ' 文字列テンプレ："{A.x}-{B.y}"
        BuildExprRawValue = ApplyTemplate(def, baseTbl, baseRow, myKey, False)
    Else
        ' 数式：{A.x}*{B.y}-{C.z}
        Dim expr As String
        expr = ReplaceTokensWithRaw(def, baseTbl, baseRow, myKey)
        BuildExprRawValue = SafeEval(expr) ' 四則演算のみ
    End If
End Function

'--- トークン "{T.c}" の生値を埋め込む ---
Private Function ReplaceTokensWithRaw(def As String, baseTbl As String, baseRow As Long, myKey As String) As String
    Dim s As String: s = def
    Dim pos As Long, pos2 As Long, token As String, valStr As String
    pos = InStr(s, "{")
    Do While pos > 0
        pos2 = InStr(pos + 1, s, "}")
        If pos2 = 0 Then Exit Do
        token = Mid$(s, pos + 1, pos2 - pos - 1) ' "A.col"
        valStr = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
        If Not IsNumeric(valStr) Then valStr = "0"
        s = Left$(s, pos - 1) & valStr & Mid$(s, pos2 + 1)
        pos = InStr(pos + Len(valStr), s, "{")
    Loop
    ReplaceTokensWithRaw = s
End Function

'--- トークン "{T.c}" をテンプレートに展開（加工前/後を切替） ---
Private Function ApplyTemplate(def As String, baseTbl As String, baseRow As Long, myKey As String, processed As Boolean) As String
    Dim s As String: s = def
    Dim pos As Long, pos2 As Long, token As String, valStr As String
    pos = InStr(s, "{")
    Do While pos > 0
        pos2 = InStr(pos + 1, s, "}")
        If pos2 = 0 Then Exit Do
        token = Mid$(s, pos + 1, pos2 - pos - 1) ' "A.col"
        If processed Then
            valStr = ResolveTokenProcessed(token, baseTbl, baseRow, myKey)
        Else
            valStr = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
        End If
        s = Left$(s, pos - 1) & valStr & Mid$(s, pos2 + 1)
        pos = InStr(pos + Len(valStr), s, "{")
    Loop
    ApplyTemplate = Replace(s, """", "")
End Function

'--- "A.col" / "{A.col}" の無加工値を取得 ---
Private Function ResolveTokenRaw(token As String, baseTbl As String, baseRow As Long, myKey As String) As String
    Dim t As String, c As String, p As Long
    token = Replace(Replace(token, "{", ""), "}", "")
    p = InStr(token, ".")
    If p = 0 Then ResolveTokenRaw = "": Exit Function
    t = Left$(token, p - 1): c = Mid$(token, p + 1)
    ResolveTokenRaw = GetValueFromTable(t, c, baseTbl, baseRow, myKey)
End Function

'--- "A.col" の加工後値（型/置換を適用）を取得（出力列のB/Cルールを適用） ---
Private Function ResolveTokenProcessed(token As String, baseTbl As String, baseRow As Long, myKey As String, _
                                       Optional outColIndex As Long = -1) As String
    Dim raw As Variant
    raw = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
    If outColIndex <= 0 Then
        ResolveTokenProcessed = CStr(raw)
    Else
        ResolveTokenProcessed = ApplyOneValueTransform(raw, m_dataType(outColIndex), m_logic(outColIndex))
    End If
End Function

'--- VALUE/CONCAT/EXPR の「加工」をまとめて実施 ---
Private Function ApplyTransformSmart(src As Variant) As Variant
    Dim rows As Long, cols As Long
    rows = UBound(src, 1): cols = UBound(src, 2)
    Dim dst() As Variant
    ReDim dst(1 To rows, 1 To cols)
    
    Dim r As Long, c As Long
    For r = 1 To rows
        For c = 1 To cols
            Select Case m_mode(c)
                Case "CONCAT"
                    ' 定義の各トークンを「加工/条件適用してから」改行で結合
                    dst(r, c) = BuildConcatProcessedValue(m_def(c), m_baseTblName, m_baseRowIdx(r), GetKeyForRow(r), c)
                    dst(r, c) = FinalizeByType(dst(r, c), m_dataType(c)) ' 最後に列型で仕上げ
                Case "EXPR"
                    If InStr(m_def(c), """") > 0 Then
                        ' テンプレはトークン加工後で展開
                        dst(r, c) = ApplyTemplate(m_def(c), m_baseTblName, m_baseRowIdx(r), GetKeyForRow(r), True)
                        dst(r, c) = FinalizeByType(dst(r, c), m_dataType(c))
                    Else
                        ' 数式：トークン加工後に評価（非数値は0）
                        Dim expr As String
                        expr = ReplaceTokensProcessedAsNumber(m_def(c), m_baseTblName, m_baseRowIdx(r), GetKeyForRow(r), c)
                        dst(r, c) = SafeEval(expr)
                        dst(r, c) = FinalizeByType(dst(r, c), m_dataType(c))
                    End If
                Case Else
                    ' VALUE：既存のセル単位加工
                    dst(r, c) = ApplyOneValueTransform(src(r, c), m_dataType(c), m_logic(c))
            End Select
        Next c
    Next r
    ApplyTransformSmart = dst
End Function

'--- 加工（型変換＋置換）を値1つに適用 ---
Private Function ApplyOneValueTransform(v As Variant, dataType As String, logic As String) As String
    Dim w As Variant: w = v
    Select Case dataType
        Case "NUMBER"
            If IsNumeric(w) And Len(w) > 0 Then w = CLng(w) Else w = ""
        Case "DATE"
            If IsDate(w) And Len(w) > 0 Then w = Format$(CDate(w), "yyyy/mm/dd") Else w = ""
        Case Else ' TEXT or 未指定
            w = CStr(w)
    End Select
    If Len(logic) > 0 Then
        Dim rules() As String, i As Long, pair() As String
        rules = Split(logic, ";")
        For i = LBound(rules) To UBound(rules)
            pair = Split(rules(i), "→")
            If UBound(pair) = 1 Then
                w = Replace(CStr(w), pair(0), pair(1))
            End If
        Next i
    End If
    ApplyOneValueTransform = CStr(w)
End Function

'--- 列型に合わせた最終整形（置換ロジックは適用しない） ---
Private Function FinalizeByType(v As Variant, dataType As String) As String
    Select Case UCase$(dataType)
        Case "NUMBER"
            If IsNumeric(v) And Len(v) > 0 Then FinalizeByType = CStr(CLng(v)) Else FinalizeByType = ""
        Case "DATE"
            If IsDate(v) And Len(v) > 0 Then FinalizeByType = Format$(CDate(v), "yyyy/mm/dd") Else FinalizeByType = ""
        Case Else
            FinalizeByType = CStr(v)
    End Select
End Function

'--- CONCAT：各トークンを加工＋条件適用してから改行結合 ---
Private Function BuildConcatProcessedValue(def As String, baseTbl As String, baseRow As Long, myKey As String, outColIndex As Long) As String
    Dim items() As String, i As Long, spec As String, acc As String, v As String
    Dim token As String, hasCond As Boolean, cond As String, label As String, raw As String
    
    items = Split(def, "|")
    acc = ""
    For i = LBound(items) To UBound(items)
        spec = Trim$(items(i))
        If Len(spec) = 0 Then GoTo CONTI
        
        ParseConcatSpec spec, token, hasCond, cond, label
        
        If hasCond Then
            ' 条件比較はRAWで（要件：完全一致なら置換文字列、違えばスキップ）
            raw = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
            If CStr(raw) = cond Then
                v = label                  ' ラベルはそのまま出す（列Cの置換は適用しない）
            Else
                v = ""                     ' スキップ
            End If
        Else
            ' 通常トークンは「その列の型/ロジック」を適用
            v = ResolveTokenProcessed(token, baseTbl, baseRow, myKey, outColIndex)
        End If
        
        If Len(v) > 0 Then
            If Len(acc) = 0 Then acc = v Else acc = acc & vbLf & v
        End If
CONTI:
    Next
    BuildConcatProcessedValue = acc
End Function

'--- EXPR：加工後トークンを数値として式へ埋め込む（非数値は0） ---
Private Function ReplaceTokensProcessedAsNumber(def As String, baseTbl As String, baseRow As Long, myKey As String, outColIndex As Long) As String
    Dim s As String: s = def
    Dim pos As Long, pos2 As Long, token As String, valStr As String
    pos = InStr(s, "{")
    Do While pos > 0
        pos2 = InStr(pos + 1, s, "}")
        If pos2 = 0 Then Exit Do
        token = Mid$(s, pos + 1, pos2 - pos - 1) ' "A.col"
        valStr = ResolveTokenProcessed(token, baseTbl, baseRow, myKey, outColIndex)
        If Not IsNumeric(valStr) Then valStr = "0"
        s = Left$(s, pos - 1) & valStr & Mid$(s, pos2 + 1)
        pos = InStr(pos + Len(valStr), s, "{")
    Loop
    ReplaceTokensProcessedAsNumber = s
End Function

'--- 出力行rのキー文字列（ベース行から生成） ---
Private Function GetKeyForRow(r As Long) As String
    Dim baseArr As Variant, baseKeyCols() As Long
    If Len(m_baseTblName) = 0 Then GetKeyForRow = "": Exit Function
    baseArr = TableData(m_baseTblName)
    baseKeyCols = CollectKeyColIndexesForBase(baseArr, m_baseTblName)
    GetKeyForRow = BuildKeyFromRow(baseArr, m_baseRowIdx(r), baseKeyCols)
End Function

'--- ベーステーブルにおけるキー列の「実列番号配列」を作る ---
Private Function CollectKeyColIndexesForBase(baseArr As Variant, baseTbl As String) As Variant
    Dim tIdx As Long, i As Long, kc As Long
    tIdx = IndexOfTable(m_tblNames, baseTbl)
    kc = 0
    For i = LBound(m_outCols) To UBound(m_outCols)
        If m_isKey(i) Then
            If (Not Not m_tblNames) <> 0 And tIdx >= 0 Then
                If UBound(m_srcCols, 2) >= tIdx Then
                    If Len(m_srcCols(i, tIdx)) > 0 Then
                        kc = kc + 1
                    End If
                End If
            End If
        End If
    Next i
    If kc = 0 Then
        CollectKeyColIndexesForBase = Array()
        Exit Function
    End If
    
    Dim idx() As Long, cur As Long
    ReDim idx(1 To kc): cur = 0
    For i = LBound(m_outCols) To UBound(m_outCols)
        If m_isKey(i) Then
            If UBound(m_srcCols, 2) >= tIdx Then
                If Len(m_srcCols(i, tIdx)) > 0 Then
                    cur = cur + 1
                    idx(cur) = FindColumnIndex(baseArr, m_srcCols(i, tIdx))
                End If
            End If
        End If
    Next i
    CollectKeyColIndexesForBase = idx
End Function

'--- 1行から複合キー文字列を作る ---
Private Function BuildKeyFromRow(arr As Variant, rowIdx As Long, keyColIdx() As Long) As String
    Dim i As Long, s As String: s = ""
    If Not Not keyColIdx Then
        For i = LBound(keyColIdx) To UBound(keyColIdx)
            If keyColIdx(i) > 0 Then s = s & "|" & CStr(arr(rowIdx, keyColIdx(i)))
        Next i
    End If
    If Len(s) > 0 Then s = Mid$(s, 2)
    BuildKeyFromRow = s
End Function

'--- テーブル配列のヘッダ行から列番号を取得 ---
Private Function FindColumnIndex(arr As Variant, colName As String) As Long
    Dim c As Long
    For c = 1 To UBound(arr, 2)
        If CStr(arr(1, c)) = colName Then
            FindColumnIndex = c
            Exit Function
        End If
    Next c
    FindColumnIndex = 0
End Function

'--- テーブル名のインデックス ---
Private Function IndexOfTable(tblNames() As String, name As String) As Long
    Dim i As Long
    For i = LBound(tblNames) To UBound(tblNames)
        If tblNames(i) = name Then
            IndexOfTable = i
            Exit Function
        End If
    Next i
    IndexOfTable = -1
End Function

'--- 任意テーブル・カラムの値をキーで解決 ---
Private Function GetValueFromTable(tbl As String, col As String, baseTbl As String, baseRow As Long, myKey As String) As String
    On Error GoTo SAFE
    Dim arr As Variant, cIdx As Long, kd As Object, rIdx As Long
    If tbl = baseTbl Then
        arr = TableData(tbl)
        cIdx = FindColumnIndex(arr, col)
        If cIdx > 0 Then GetValueFromTable = CStr(arr(baseRow, cIdx)) Else GetValueFromTable = ""
    Else
        Set kd = KeyIndex(tbl)
        If kd Is Nothing Then GetValueFromTable = "": Exit Function
        If Not kd.Exists(myKey) Then GetValueFromTable = "": Exit Function
        rIdx = kd(myKey)
        arr = TableData(tbl)
        cIdx = FindColumnIndex(arr, col)
        If cIdx > 0 Then GetValueFromTable = CStr(arr(rIdx, cIdx)) Else GetValueFromTable = ""
    End If
    Exit Function
SAFE:
    GetValueFromTable = ""
End Function

'==============================
' Masterへ貼り付け（既存テーブル列構成を維持しつつ行数調整）
'==============================
Private Sub PasteToMaster(ws As Worksheet, dataArr As Variant)
    Dim lo As ListObject, rows As Long, cols As Long
    Set lo = ws.ListObjects(1)
    
    rows = UBound(dataArr, 1)
    cols = UBound(dataArr, 2)
    
    If lo.ListColumns.Count <> cols Then
        WriteLog "ERROR", "Master columns mismatch. Master=" & lo.ListColumns.Count & " Mapping=" & cols
        MsgBox "Masterテーブルの列数がMappingの出力列数と一致しません。", vbCritical
        Exit Sub
    End If
    
    Dim newRange As Range
    Set newRange = lo.HeaderRowRange.Resize(rows + 1, lo.ListColumns.Count)
    lo.Resize newRange
    
    lo.DataBodyRange.Value = dataArr
End Sub

'==============================
' CSV出力（引用符・改行対応 / エンコード対応）
'==============================
Private Sub WriteRangeAsCsvWithEncoding(lo As ListObject, filePath As String, encMode As String)
    Dim arr As Variant, rows As Long, cols As Long
    Dim sb As String
    Dim r As Long, c As Long
    
    arr = lo.DataBodyRange.Value
    rows = UBound(arr, 1): cols = UBound(arr, 2)
    
    sb = ""
    For r = 1 To rows
        Dim line As String: line = ""
        For c = 1 To cols
            Dim cell As String: cell = CStr(arr(r, c))
            If InStr(cell, """") > 0 Then cell = Replace(cell, """", """""")
            If InStr(cell, ",") > 0 Or InStr(cell, vbCr) > 0 Or InStr(cell, vbLf) > 0 Then
                cell = """" & cell & """"
            End If
            line = line & cell & IIf(c < cols, ",", "")
        Next c
        sb = sb & line & vbCrLf
    Next r
    
    WriteTextFile filePath, sb, encMode
End Sub

'==============================
' CSVパーサ（引用符・改行対応 / RFC4180簡易）+ エンコード対応
'==============================
Private Function ParseCsvFile(filePath As String) As Variant
    Dim text As String
    text = ReadTextFile(filePath, CurrentEncodingMode) ' AUTO/UTF-8/SHIFT_JIS/UTF-16LE
    ParseCsvFile = ParseCsvText(text)
End Function

Private Function ParseCsvText(ByVal txt As String) As Variant
    Dim i As Long, ch As String * 1
    Dim inQuote As Boolean
    Dim field As String, row As Collection, rows As Collection
    
    Set rows = New Collection
    Set row = New Collection
    field = ""
    inQuote = False
    
    For i = 1 To Len(txt)
        ch = Mid$(txt, i, 1)
        If inQuote Then
            If ch = """" Then
                If i < Len(txt) And Mid$(txt, i + 1, 1) = """" Then
                    field = field & """": i = i + 1
                Else
                    inQuote = False
                End If
            Else
                field = field & ch
            End If
        Else
            Select Case ch
                Case """": inQuote = True
                Case ",":  row.Add field: field = ""
                Case vbCr ' 無視
                Case vbLf: row.Add field: field = "": rows.Add row: Set row = New Collection
                Case Else: field = field & ch
            End Select
        End If
    Next i
    row.Add field: rows.Add row
    
    Dim maxCol As Long, r As Long
    For r = 1 To rows.Count
        If rows(r).Count > maxCol Then maxCol = rows(r).Count
    Next r
    
    Dim result() As Variant, rr As Long, cc As Long
    If rows.Count = 0 Then
        ReDim result(1 To 1, 1 To 1): result(1, 1) = ""
        ParseCsvText = result: Exit Function
    End If
    
    ReDim result(1 To rows.Count, 1 To maxCol)
    For rr = 1 To rows.Count
        For cc = 1 To rows(rr).Count
            result(rr, cc) = rows(rr)(cc)
        Next cc
        For cc = rows(rr).Count + 1 To maxCol
            result(rr, cc) = ""
        Next cc
    Next rr
    ParseCsvText = result
End Function

'==============================
' 文字コード：読み込み（ADODB.Stream） + 自動判定(BOM)
'==============================
Private Function ReadTextFile(filePath As String, encMode As String) As String
    Dim mode As String
    mode = UCase$(encMode)
    If mode = "AUTO" Then mode = DetectEncoding(filePath)
    
    Dim stm As Object ' ADODB.Stream
    Set stm = CreateObject("ADODB.Stream")
    stm.Type = 2 ' text
    Select Case mode
        Case "UTF-8":     stm.Charset = "utf-8"
        Case "UTF-16LE":  stm.Charset = "unicode"
        Case "SHIFT_JIS": stm.Charset = "shift_jis"
        Case Else:        stm.Charset = "shift_jis"
    End Select
    stm.Open
    stm.LoadFromFile filePath
    ReadTextFile = stm.ReadText(-1)
    stm.Close
    Set stm = Nothing
End Function

Private Function DetectEncoding(filePath As String) As String
    Dim f As Integer, b1 As Byte, b2 As Byte, b3 As Byte
    On Error GoTo FAIL
    f = FreeFile
    Open filePath For Binary As #f
    If LOF(f) >= 2 Then
        Get #f, , b1: Get #f, , b2
        If b1 = &HEF And b2 = &HBB And LOF(f) >= 3 Then
            Get #f, , b3
            If b3 = &HBF Then DetectEncoding = "UTF-8": Close #f: Exit Function
        ElseIf b1 = &HFF And b2 = &HFE Then
            DetectEncoding = "UTF-16LE": Close #f: Exit Function
        End If
    End If
    Close #f
FAIL:
    If Len(DetectEncoding) = 0 Then DetectEncoding = "SHIFT_JIS"
End Function

'==============================
' 文字コード：書き出し（ADODB.Stream）
'==============================
Private Sub WriteTextFile(filePath As String, ByVal content As String, encMode As String)
    Dim stm As Object ' ADODB.Stream
    Dim mode As String
    mode = UCase$(encMode)
    If mode = "AUTO" Then mode = "UTF-8" ' AUTO時はUTF-8(BOM)で出力
    
    Set stm = CreateObject("ADODB.Stream")
    stm.Type = 2 ' text
    Select Case mode
        Case "UTF-8":     stm.Charset = "utf-8"
        Case "UTF-16LE":  stm.Charset = "unicode"
        Case "SHIFT_JIS": stm.Charset = "shift_jis"
        Case Else:        stm.Charset = "utf-8"
    End Select
    stm.Open
    stm.WriteText content
    stm.SaveToFile filePath, 2 ' adSaveCreateOverWrite
    stm.Close
    Set stm = Nothing
End Sub

'==============================
' ログ
'==============================
Private Sub EnsureFolder(pathWithSlash As String)
    If Len(Dir(pathWithSlash, vbDirectory)) = 0 Then MkDir pathWithSlash
End Sub

Private Function TimeStamp() As String
    TimeStamp = Format(Now, "yyyymmdd_hhnnss")
End Function

Private Sub WriteLog(level As String, message As String)
    On Error Resume Next
    Dim basePath As String, logDir As String, logPath As String
    basePath = ThisWorkbook.Path
    logDir = basePath & "\" & LOG_FOLDER & "\"
    If Len(Dir(logDir, vbDirectory)) = 0 Then MkDir logDir
    logPath = logDir & "tool_" & Format(Date, "yyyymmdd") & ".log"
    
    Dim f As Integer
    f = FreeFile
    Open logPath For Append As #f
    Print #f, Format(Now, "yyyy-mm-dd HH:nn:ss"); " [" & level & "] "; message
    Close #f
    On Error GoTo 0
End Sub

'==============================
' 簡易数式評価（+ - * / と () のみ）
'==============================
Private Function SafeEval(ByVal expr As String) As Double
    expr = Replace(expr, " ", "")
    Dim nums() As Double, ops() As String, nTop As Long, oTop As Long
    ReDim nums(1 To 1): ReDim ops(1 To 1): nTop = 0: oTop = 0
    
    Dim i As Long, ch As String, num As String
    i = 1
    Do While i <= Len(expr)
        ch = Mid$(expr, i, 1)
        If ch Like "[0-9.]" Then
            num = ""
            Do While i <= Len(expr) And Mid$(expr, i, 1) Like "[0-9.]"
                num = num & Mid$(expr, i, 1): i = i + 1
            Loop
            nTop = nTop + 1: ReDim Preserve nums(1 To nTop)
            On Error Resume Next: nums(nTop) = CDbl(num): On Error GoTo 0
            Continue Do
        ElseIf ch = "(" Then
            oTop = oTop + 1: ReDim Preserve ops(1 To oTop): ops(oTop) = ch
        ElseIf ch = ")" Then
            Do While oTop > 0 And ops(oTop) <> "("
                ApplyOp nums, nTop, ops, oTop
            Loop
            If oTop > 0 And ops(oTop) = "(" Then oTop = oTop - 1
        ElseIf ch = "+" Or ch = "-" Or ch = "*" Or ch = "/" Then
            Do While oTop > 0 And Precedence(ops(oTop)) >= Precedence(ch)
                ApplyOp nums, nTop, ops, oTop
            Loop
            oTop = oTop + 1: ReDim Preserve ops(1 To oTop): ops(oTop) = ch
        End If
        i = i + 1
    Loop
    Do While oTop > 0
        ApplyOp nums, nTop, ops, oTop
    Loop
    If nTop > 0 Then SafeEval = nums(nTop) Else SafeEval = 0
End Function

Private Function Precedence(op As String) As Long
    Select Case op
        Case "+", "-": Precedence = 1
        Case "*", "/": Precedence = 2
        Case Else:     Precedence = 0
    End Select
End Function

Private Sub ApplyOp(ByRef nums() As Double, ByRef nTop As Long, ByRef ops() As String, ByRef oTop As Long)
    If nTop < 2 Or oTop = 0 Then Exit Sub
    Dim b As Double, a As Double, op As String, res As Double
    b = nums(nTop): nTop = nTop - 1
    a = nums(nTop): nTop = nTop - 1
    op = ops(oTop): oTop = oTop - 1
    Select Case op
        Case "+": res = a + b
        Case "-": res = a - b
        Case "*": res = a * b
        Case "/": If b = 0 Then res = 0 Else res = a / b
    End Select
    nTop = nTop + 1: ReDim Preserve nums(1 To nTop): nums(nTop) = res
End Sub