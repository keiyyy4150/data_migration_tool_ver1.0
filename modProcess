Option Explicit

'======================================================
' パイプライン切替、Import/Process/Clear 本体
'======================================================

'--- パイプライン切替（Main）---
Public Sub UsePipelineMain()
    CurrentMappingTableName = "Mapping_Main"
    CurrentMasterTableName  = "Master_Main"
    CurrentExportPrefix     = "MAIN_"
    WriteLog "INFO", "Switched pipeline: Main"
End Sub

'--- パイプライン切替（List：1:N 展開）---
Public Sub UsePipelineList()
    CurrentMappingTableName = "Mapping_List"
    CurrentMasterTableName  = "Master_List"
    CurrentExportPrefix     = "LIST_"
    WriteLog "INFO", "Switched pipeline: List"
End Sub

'--- エンコード選択（任意） ---
Public Sub ChooseEncoding()
    Dim s As String
    s = InputBox("読み込み・書き出しエンコード（AUTO/UTF-8/Shift_JIS/UTF-16LE）", "Encoding Mode", IIf(Len(CurrentEncodingMode) = 0, "AUTO", CurrentEncodingMode))
    If s = "False" Then Exit Sub
    s = UCase$(Trim$(s))
    Select Case s
        Case "AUTO", "UTF-8", "UTF8": CurrentEncodingMode = IIf(s = "UTF8", "UTF-8", s)
        Case "SHIFT_JIS", "SJIS", "CP932": CurrentEncodingMode = "SHIFT_JIS"
        Case "UTF-16LE", "UTF16LE", "UNICODE": CurrentEncodingMode = "UTF-16LE"
        Case Else: CurrentEncodingMode = "AUTO"
    End Select
    EnsureFolder ThisWorkbook.Path & "\" & LOG_FOLDER & "\"
    WriteLog "INFO", "Encoding set: " & CurrentEncodingMode
    MsgBox "Encoding Mode: " & CurrentEncodingMode, vbInformation
End Sub

'--- Import：CSV読込→キー辞書→JOIN(無加工)→Masterへ貼付 ---
Public Sub ImportFiles()
    On Error GoTo EH
    Dim tStart As Date: tStart = Now
    If Len(CurrentEncodingMode) = 0 Then CurrentEncodingMode = "AUTO"
    If Len(CurrentMappingTableName) = 0 Then UsePipelineMain

    ' Mapping読込
    Dim ok As Boolean
    ok = ReadMappingFromTableName(CurrentMappingTableName)
    If Not ok Then
        WriteLog "ERROR", "Mapping read failed"
        MsgBox "Mappingの読み取りに失敗しました。", vbCritical
        Exit Sub
    End If

    ' CSVロード
    Dim importPath As String: importPath = ThisWorkbook.Path & "\" & IMPORT_FOLDER & "\"
    EnsureFolder ThisWorkbook.Path & "\" & LOG_FOLDER & "\"
    WriteLog "INFO", "ImportFiles: start / Encoding=" & CurrentEncodingMode & " / MappingTable=" & CurrentMappingTableName

    Set TableData = CreateObject("Scripting.Dictionary")
    If Not LoadAllCsv(importPath, Map_TblNames, TableData) Then
        WriteLog "ERROR", "LoadAllCsv failed"
        Exit Sub
    End If

    ' キー辞書（1:N用に Collection 保持）
    Set KeyIndex = CreateObject("Scripting.Dictionary")
    BuildKeyIndexes KeyIndex

    ' ベーステーブル決定
    BaseTableName = PickBaseTableName()
    If Len(BaseTableName) = 0 And (Not Not Map_TblNames) <> 0 Then BaseTableName = Map_TblNames(0)
    WriteLog "INFO", "BaseTable=" & BaseTableName

    ' 無加工JOIN
    RawJoined = BuildJoinedRaw()
    HasRaw = True: IsProcessed = False

    ' Masterへ貼付
    Dim masterTbl As ListObject
    Set masterTbl = GetTableByName(CurrentMasterTableName)
    If masterTbl Is Nothing Then
        MsgBox "Masterテーブル '" & CurrentMasterTableName & "' が見つかりません。", vbCritical
        Exit Sub
    End If
    PasteToMasterByTable masterTbl, RawJoined

    WriteLog "INFO", "ImportFiles: done / rows=" & UBound(RawJoined, 1) & " / cols=" & UBound(RawJoined, 2) & " / elapsed=" & Format(Now - tStart, "hh:nn:ss")
    MsgBox "ファイルインポート完了（無加工をMasterへ反映）", vbInformation
    Exit Sub
EH:
    WriteLog "ERROR", "ImportFiles error: " & Err.Number & " " & Err.Description
    MsgBox "ImportFilesでエラー: " & Err.Description, vbCritical
End Sub

'--- Process：無加工→型/置換/式などの加工適用 ---
Public Sub ProcessData()
    On Error GoTo EH
    Dim tStart As Date: tStart = Now
    If Not HasRaw Then
        MsgBox "先に『インポート』を実行してください。", vbExclamation
        Exit Sub
    End If
    If Len(CurrentMappingTableName) = 0 Then UsePipelineMain

    If Not ReadMappingFromTableName(CurrentMappingTableName) Then
        WriteLog "ERROR", "Mapping read failed in ProcessData"
        MsgBox "Mappingの読み取りに失敗しました。", vbCritical
        Exit Sub
    End If

    Dim procArr As Variant
    procArr = ApplyTransformSmart(RawJoined)

    Dim masterTbl As ListObject
    Set masterTbl = GetTableByName(CurrentMasterTableName)
    If masterTbl Is Nothing Then
        MsgBox "Masterテーブル '" & CurrentMasterTableName & "' が見つかりません。", vbCritical
        Exit Sub
    End If
    PasteToMasterByTable masterTbl, procArr
    IsProcessed = True

    WriteLog "INFO", "ProcessData: done / rows=" & UBound(procArr, 1) & " / cols=" & UBound(procArr, 2) & " / elapsed=" & Format(Now - tStart, "hh:nn:ss")
    MsgBox "データ加工完了（Masterへ反映）", vbInformation
    Exit Sub
EH:
    WriteLog "ERROR", "ProcessData error: " & Err.Number & " " & Err.Description
    MsgBox "ProcessDataでエラー: " & Err.Description, vbCritical
End Sub

'--- Clear：Masterの値と中間データ破棄 ---
Public Sub ClearData()
    On Error Resume Next
    Dim masterTbl As ListObject
    If Len(CurrentMasterTableName) = 0 Then UsePipelineMain
    Set masterTbl = GetTableByName(CurrentMasterTableName)
    If Not masterTbl Is Nothing Then
        If Not masterTbl.DataBodyRange Is Nothing Then masterTbl.DataBodyRange.ClearContents
    End If
    On Error GoTo 0

    HasRaw = False: IsProcessed = False
    Erase RawJoined: Erase BaseRowIndex
    BaseTableName = ""
    Set TableData = Nothing: Set KeyIndex = Nothing

    WriteLog "INFO", "ClearData: Master cleared & memory freed"
    MsgBox "初期化しました。", vbInformation
End Sub

'--- importFiles から必要CSVを読み込む（存在チェック付き） ---
Public Function LoadAllCsv(importPath As String, tblNames() As String, ByRef dict As Object) As Boolean
    Dim i As Long, filePath As String, extra As String
    If (Not Not tblNames) = 0 Then
        If Dir(importPath, vbDirectory) = "" Then
            MsgBox "入力フォルダが存在しません：" & importPath, vbCritical
            LoadAllCsv = False: Exit Function
        End If
        LoadAllCsv = True: Exit Function
    End If

    ' 必須CSV存在チェック
    For i = LBound(tblNames) To UBound(tblNames)
        filePath = importPath & tblNames(i) & ".csv"
        If Dir(filePath) = "" Then
            MsgBox "必要ファイルが不足しています：" & vbCrLf & filePath, vbCritical
            LoadAllCsv = False: Exit Function
        End If
    Next i

    ' 余分CSVの通知（続行）
    Dim fn As String, isListed As Boolean
    fn = Dir(importPath & "*.csv")
    Do While Len(fn) > 0
        isListed = False
        For i = LBound(tblNames) To UBound(tblNames)
            If LCase$(fn) = LCase$(tblNames(i) & ".csv") Then isListed = True: Exit For
        Next i
        If Not isListed Then
            extra = extra & IIf(Len(extra) > 0, vbCrLf, "") & (importPath & fn)
        End If
        fn = Dir
    Loop
    If Len(extra) > 0 Then
        WriteLog "WARN", "Extra CSV exists (ignored):" & vbCrLf & extra
        MsgBox "定義外のCSVがあります（処理は続行）。" & vbCrLf & extra, vbExclamation
    End If

    ' 実読込
    For i = LBound(tblNames) To UBound(tblNames)
        filePath = importPath & tblNames(i) & ".csv"
        dict(tblNames(i)) = ParseCsvFile(filePath)
        WriteLog "INFO", "Loaded: " & filePath & " / rows=" & UBound(dict(tblNames(i)), 1)
    Next i

    LoadAllCsv = True
End Function

'--- Masterへ貼り付け（ListObject指定） ---
Public Sub PasteToMasterByTable(masterTbl As ListObject, dataArr As Variant)
    Dim rows As Long, cols As Long
    rows = UBound(dataArr, 1): cols = UBound(dataArr, 2)
    If masterTbl.ListColumns.Count <> cols Then
        WriteLog "ERROR", "Master columns mismatch. Master=" & masterTbl.ListColumns.Count & " Mapping=" & cols
        MsgBox "Masterテーブルの列数がMappingの出力列数と一致しません。", vbCritical
        Exit Sub
    End If
    Dim newRange As Range
    Set newRange = masterTbl.HeaderRowRange.Resize(rows + 1, cols)
    masterTbl.Resize newRange
    masterTbl.DataBodyRange.Value = dataArr
End Sub