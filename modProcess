Option Explicit

'=== 既定行数にマスターの表サイズを戻す（B4セル：行数設定 / 空なら20000） ===
Private Sub ResetMasterSize(masterLo As ListObject)
    On Error Resume Next
    If masterLo Is Nothing Then Exit Sub
    Dim ws As Worksheet: Set ws = masterLo.Parent
    Dim reserve As Long
    reserve = CLng(Val(ws.Range("B4").Value)) ' 任意セルに既定行数を置く運用。空なら下で既定値に。
    If reserve <= 0 Then reserve = 20000

    Dim cols As Long: cols = masterLo.ListColumns.Count
    Dim newRg As Range
    Set newRg = masterLo.HeaderRowRange.Resize(reserve + 1, cols)
    masterLo.Resize newRg
    If Not masterLo.DataBodyRange Is Nothing Then masterLo.DataBodyRange.ClearContents
    On Error GoTo 0
End Sub


'==============================
' パイプライン切替（Main / List）
'==============================
Public Sub UsePipelineMain()
    CurrentMappingTableName = "Mapping_Main"
    CurrentMasterTableName = "Master_Main"
    CurrentExportBaseName = "main_Keihyouhounavi_Konpurasoudan"
    AllowOneToMany = False
    WriteLog "INFO", "Switched pipeline: Main"
End Sub

Public Sub UsePipelineList()
    CurrentMappingTableName = "Mapping_List"
    CurrentMasterTableName = "Master_List"
    CurrentExportBaseName = "list_Keihyouhounavi_Konpurasoudan"
    AllowOneToMany = True
    WriteLog "INFO", "Switched pipeline: List"
End Sub

'==============================
' エンコード選択
'==============================
Public Sub ChooseEncoding()
    Dim s As String
    s = InputBox( _
        "読み込み・書き出しのエンコードを指定してください。" & vbCrLf & _
        "AUTO / UTF-8 / Shift_JIS / UTF-16LE", _
        "Encoding Mode", IIf(Len(CurrentEncodingMode) = 0, "AUTO", CurrentEncodingMode))
    If s = "False" Then Exit Sub
    s = UCase$(Trim$(s))
    Select Case s
        Case "AUTO", "UTF-8", "UTF8": CurrentEncodingMode = IIf(s = "UTF8", "UTF-8", s)
        Case "SHIFT_JIS", "SJIS", "CP932": CurrentEncodingMode = "SHIFT_JIS"
        Case "UTF-16LE", "UTF16LE", "UNICODE": CurrentEncodingMode = "UTF-16LE"
        Case Else: CurrentEncodingMode = "AUTO"
    End Select
    EnsureFolder ThisWorkbook.Path & "\" & LOG_FOLDER & "\"
    WriteLog "INFO", "Encoding set: " & CurrentEncodingMode
    MsgBox "Encoding Mode: " & CurrentEncodingMode, vbInformation
End Sub

'==============================
' Import：CSV読込→キー索引→JOIN（無加工）→Master貼付
'==============================
Public Sub ImportFiles()
    On Error GoTo EH
    Dim tStart As Date: tStart = Now
    
    If Len(CurrentEncodingMode) = 0 Then CurrentEncodingMode = "AUTO"
    If Len(CurrentMappingTableName) = 0 Then UsePipelineMain
    
    Dim ok As Boolean
    ok = ReadMappingFromTableName(CurrentMappingTableName)
    If Not ok Then
        WriteLog "ERROR", "Mapping read failed"
        MsgBox "Mapping の読み取りに失敗しました。", vbCritical
        Exit Sub
    End If
    
    WriteLog "INFO", "Mapping read succeeded"
    
    Dim importPath As String: importPath = ThisWorkbook.Path & "\" & IMPORT_FOLDER & "\"
    EnsureFolder ThisWorkbook.Path & "\" & LOG_FOLDER & "\"
    WriteLog "INFO", "ImportFiles: start / Encoding=" & CurrentEncodingMode & " / MappingTable=" & CurrentMappingTableName
    
    Set TableData = CreateObject("Scripting.Dictionary")
    If Not LoadAllCsv(importPath, Map_TblNames, TableData) Then
        WriteLog "ERROR", "LoadAllCsv failed"
        Exit Sub
    End If
    
    WriteLog "INFO", "LoadAllCsv succeeded"
    
    ' キー辞書（Single & Multi）
    BuildKeyIndexes
    
    WriteLog "INFO", "BuildKey succeeded"
    
    ' ベーステーブル選定（キー成立の最初、なければ先頭）
    m_baseTblName = PickBaseTableName(Map_TblNames, Map_SrcCols, Map_IsKey)
    If Len(m_baseTblName) = 0 And (Not Not Map_TblNames) <> 0 Then m_baseTblName = Map_TblNames(0)
    WriteLog "INFO", "BaseTable=" & m_baseTblName
    
    WriteLog "INFO", "PickBaseTableName succeeded"
     
    ' 無加工JOIN
    RawJoined = BuildJoinedRaw(m_baseTblName)
    HasRaw = True: IsProcessed = False
    
    WriteLog "INFO", "RawJoined succeeded"
    
    ' Masterへ貼付
    Dim masterLo As ListObject
    Set masterLo = GetListObjectByName(CurrentMasterTableName)
    If masterLo Is Nothing Then
        MsgBox "Masterテーブルが見つかりません: " & CurrentMasterTableName, vbCritical
        Exit Sub
    End If
    PasteToMasterByTable masterLo, RawJoined
    
    WriteLog "INFO", "masterLo succeeded"
    
    WriteLog "INFO", "ImportFiles: done / rows=" & UBound(RawJoined, 1) & " / cols=" & UBound(RawJoined, 2) & " / elapsed=" & Format(Now - tStart, "hh:nn:ss")
    MsgBox "ファイルインポート完了（無加工をMasterへ反映）", vbInformation
    Exit Sub
EH:
    WriteLog "ERROR", "ImportFiles error: " & Err.Number & " " & Err.Description
    MsgBox "ImportFilesでエラー: " & Err.Description, vbCritical
End Sub

' ベーステーブル選定
Private Function PickBaseTableName(tblNames() As String, srcCols As Variant, isKey() As Boolean) As String
    Dim t As Long, i As Long
    If (Not Not tblNames) = 0 Then Exit Function
    For t = LBound(tblNames) To UBound(tblNames)
        For i = LBound(isKey) To UBound(isKey)
            If isKey(i) Then
                If UBound(srcCols, 2) >= t Then
                    If Len(srcCols(i, t)) > 0 Then
                        PickBaseTableName = tblNames(t)
                        Exit Function
                    End If
                End If
            End If
        Next
    Next
    PickBaseTableName = tblNames(LBound(tblNames))
End Function

'==============================
' Process：加工適用 → Masterへ
'==============================
Public Sub ProcessData()
    On Error GoTo EH
    Dim tStart As Date: tStart = Now
    If Not HasRaw Then
        MsgBox "先に『ファイルインポート』を実行してください。", vbExclamation
        Exit Sub
    End If
    If Len(CurrentMappingTableName) = 0 Then UsePipelineMain
    
    Dim ok As Boolean
    ok = ReadMappingFromTableName(CurrentMappingTableName)
    If Not ok Then
        WriteLog "ERROR", "Mapping read failed in ProcessData"
        MsgBox "Mapping の読み取りに失敗しました。", vbCritical
        Exit Sub
    End If
    
    Dim procArr As Variant
    procArr = ApplyTransformSmart(RawJoined)
    
    Dim masterLo As ListObject
    Set masterLo = GetListObjectByName(CurrentMasterTableName)
    If masterLo Is Nothing Then
        MsgBox "Masterテーブルが見つかりません: " & CurrentMasterTableName, vbCritical
        Exit Sub
    End If
    PasteToMasterByTable masterLo, procArr
    IsProcessed = True
    
    WriteLog "INFO", "ProcessData: done / rows=" & UBound(procArr, 1) & " / cols=" & UBound(procArr, 2) & " / elapsed=" & Format(Now - tStart, "hh:nn:ss")
    MsgBox "データ加工完了（Masterへ反映）", vbInformation
    Exit Sub
EH:
    WriteLog "ERROR", "ProcessData error: " & Err.Number & " " & Err.Description
    MsgBox "ProcessDataでエラー: " & Err.Description, vbCritical
End Sub

'==============================
' Clear：Masterクリア＆中間データ破棄（安全版）
'==============================
Public Sub ClearData()
    Dim prevCalc As XlCalculation
    Dim prevUpd As Boolean, prevEvt As Boolean, prevDisp As Boolean
    Dim t0 As Double: t0 = Timer

    ' パイプライン未設定なら既定へ
    If Len(CurrentMasterTableName) = 0 Then UsePipelineMain

    ' アプリ状態を退避＆高速化設定
    On Error Resume Next
    prevUpd = Application.ScreenUpdating
    prevEvt = Application.EnableEvents
    prevDisp = Application.DisplayAlerts
    prevCalc = Application.Calculation
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.DisplayAlerts = False
    Application.Calculation = xlCalculationManual
    On Error GoTo 0

    On Error GoTo EH
    Dim lo As ListObject
    Set lo = GetListObjectByName(CurrentMasterTableName)
    If Not lo Is Nothing Then
        ' フィルタがかかっていたら解除（削除速度が上がる & エラー回避）
        On Error Resume Next
        If Not lo.AutoFilter Is Nothing Then lo.AutoFilter.ShowAllData
        On Error GoTo 0

        If Not lo.DataBodyRange Is Nothing Then
            lo.DataBodyRange.Delete
        End If
    End If

    ' 中間データの解放（未初期化でも安全に呼べるよう注意）
    HasRaw = False
    IsProcessed = False

    On Error Resume Next
    If (Not Not RawJoined) <> 0 Then Erase RawJoined  ' 配列なら解放
    If (Not Not m_baseRowIdx) <> 0 Then Erase m_baseRowIdx
    On Error GoTo 0

    m_baseTblName = ""
    Set TableData = Nothing
    Set KeyIndexSingle = Nothing
    Set KeyIndexMulti = Nothing

    WriteLog "INFO", "ClearData: cleared in " & Format(Timer - t0, "0.00") & "s"

DONE:
    ' アプリ状態を戻す
    On Error Resume Next
    Application.ScreenUpdating = prevUpd
    Application.EnableEvents = prevEvt
    Application.DisplayAlerts = prevDisp
    Application.Calculation = prevCalc
    On Error GoTo 0

    MsgBox "初期化しました。", vbInformation
    Exit Sub

EH:
    On Error Resume Next
    Application.ScreenUpdating = prevUpd
    Application.EnableEvents = prevEvt
    Application.DisplayAlerts = prevDisp
    Application.Calculation = prevCalc
    On Error GoTo 0
    WriteLog "ERROR", "ClearData error: " & Err.Number & " " & Err.Description
    MsgBox "ClearDataでエラー: " & Err.Description, vbCritical
End Sub


'==============================
' Masterへ貼付（行数だけ合わせて一括代入）
'==============================
Public Sub PasteToMasterByTable(masterTbl As ListObject, dataArr As Variant)
    Dim rows As Long, cols As Long
    rows = UBound(dataArr, 1): cols = UBound(dataArr, 2)
    If masterTbl.ListColumns.Count <> cols Then
        WriteLog "ERROR", "Master columns mismatch. Master=" & masterTbl.ListColumns.Count & " Mapping=" & cols
        MsgBox "Masterテーブルの列数がMappingの出力列数と一致しません。", vbCritical
        Exit Sub
    End If
    Dim newRange As Range
    Set newRange = masterTbl.HeaderRowRange.Resize(rows + 1, cols)
    masterTbl.Resize newRange
    masterTbl.DataBodyRange.Value = dataArr
End Sub
